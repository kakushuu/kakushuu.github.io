{"pages":[{"title":"","text":"body, html { font-family: arial; } .map { float: left; padding: 5px; border: solid 1px #eee; border-radius: 5px; } .graticule { fill: none; stroke: #777; stroke-width: 0.5px; stroke-opacity: 0.5; pointer-events: all; } .land { fill: none; stroke: #000; stroke-width: 1; } // https://stackoverflow.com/questions/43772975/drag-rotate-projection-in-d3-v4 var width = 600, height = 600, scale = 200, origin = { x: 55, y: -40, }; var world; // 选择body、div确定绘制地球位置和宽高 var svg = d3 .select(\"body\") .select(\"#map\") .append(\"svg\") .attr(\"width\", width) .attr(\"height\", height); var group = svg.append(\"g\").datum({ x: 0, y: 0, }); // 定义投影坐标系统 var projection = d3 .geoOrthographic() .scale(scale) .translate([width / 2, height / 2]) .rotate([origin.x, origin.y]) .center([0, 0]) .clipAngle(90); // 生成地理投影路径 var geoPath = d3.geoPath().projection(projection); // 创建地球网格 var graticule = d3.geoGraticule(); // 地球缩放和拖拽 svg.call(d3.zoom().on(\"zoom\", zoomed)); group.call(d3.drag().on(\"drag\", dragged)); // code snippet from http://stackoverflow.com/questions/36614251 var lambda = d3.scaleLinear().domain([-width, width]).range([-180, 180]); var phi = d3.scaleLinear().domain([-height, height]).range([90, -90]); // 给地球添加网格并定义样式 group .append(\"path\") .datum(graticule) .attr(\"class\", \"graticule\") .attr(\"d\", geoPath); function dragged(d) { var r = { x: lambda((d.x = d3.event.x)), y: phi((d.y = d3.event.y)), }; projection.rotate([origin.x + r.x, origin.y + r.y]); updatePaths(svg, graticule, world, geoPath); } function zoomed() { var transform = d3.event.transform; var k = Math.sqrt(100 / projection.scale()); projection.scale(scale * transform.k); updatePaths(svg, graticule, world, geoPath); } function updatePaths(svg, graticule, world, geoPath) { svg.selectAll(\"path.graticule\").datum(graticule).attr(\"d\", geoPath); svg.selectAll(\"path.land\").datum(world).attr(\"d\", geoPath); } // 加载全球json数据，绘制陆地 d3.json(\"world-110m.json\", function (error, worldJSON) { if (error) throw error; world = topojson.feature(worldJSON, worldJSON.objects.land); group .append(\"path\") .datum(world) .attr(\"class\", \"land\") .attr(\"d\", geoPath); }); var i = 0; function redraw() { let proj = projection.rotate([0.2 * i, 0, 0]), path = d3.geoPath().projection(projection); group .selectAll(\"path\") .datum(world) .attr(\"class\", \"land\") .attr(\"d\", geoPath); group .select(\"path\") .datum(graticule) .attr(\"class\", \"graticule\") .attr(\"d\", geoPath); i++; window.requestAnimationFrame(redraw); } // 调用地球重绘函数 //window.requestAnimationFrame(redraw);","link":"/test_files/A_numbers_with_map.html"},{"title":"","text":"","link":"/test_files/D3_map.html"},{"title":"","text":"G2 // // 数据来源于 https://github.com/react-d3/react-d3-map-bubble fetch('https://gw.alipayobjects.com/os/antvdemo/assets/data/world.geo.json') .then(res => res.json()) .then(mapData => { // fetch('https://gw.alipayobjects.com/os/antvdemo/assets/data/earthquake.json') fetch('data/citydata.json') .then(res => res.json()) .then(data => { const chart = new G2.Chart({ container: 'container', autoFit: true, height: 500, padding: [0, 20, 40] }); // force sync scales chart.scale({ x: { sync: true }, y: { sync: true } }); chart.coordinate('rect').reflect('y'); chart.legend(false); chart.axis(false); // style the tooltip chart.tooltip({ showTitle: true, shared: true, showMarkers: false, containerTpl: '', itemTpl: '{name}{value}', domStyles: { 'g2-tooltip': { borderRadius: '2px', backgroundColor: '#DDDDDD', padding: 0, border: '1px solid #333' } } }); // data set const ds = new DataSet(); // draw the map 绘制地图——保留 const dv = ds.createView('back') .source(mapData, { type: 'GeoJSON' }) .transform({ type: 'geo.projection', projection: 'geoMercator', as: ['x', 'y', 'centroidX', 'centroidY'] }); const bgView = chart.createView(); bgView.data(dv.rows); bgView.tooltip(false); bgView.polygon() .position('x*y') .style({ fill: '#DDDDDD', stroke: '#b1b1b1', lineWidth: 0.5, fillOpacity: 0.85 }); // draw the bubble plot 绘制气泡————更改数据，套用 const userData = ds.createView().source(data); userData.transform({ type: 'map', callback: obj => { const projectedCoord = dv.geoProjectPosition([obj.lng * 1, obj.lat * 1], 'geoMercator'); obj.x = projectedCoord[0]; obj.y = projectedCoord[1]; // obj.deaths = obj.deaths * 1;//死亡人数 obj.number = obj.number * 10; // obj.magnitude = obj.magnitude * 1;//震级 return obj; } }); const pointView = chart.createView(); pointView.data(userData.rows); pointView.point() .position('x*y') .size('number', [4, 15]) .shape('circle') .color('#FF2F29') // .tooltip('date*location*lat*lng*deaths*magnitude') 提示 .tooltip('origin*number') .style({ fillOpacity: 0.45, }) .state({ active: { style: { lineWidth: 1, stroke: '#FF2F29' } } }); pointView.interaction('element-active'); chart.render(); }); });","link":"/test_files/G2_map.html"},{"title":"Three-dimensional Mapping","text":"$(function () { var map, c, scale, updateMap, symbols = []; $.fn.qtip.defaults.style.classes = \"ui-tooltip-bootstrap\"; $.fn.qtip.defaults.style.def = false; c = $(\"#map\"); c.height(c.width() * 0.5); map = kartograph.map(\"#map\"); map.loadMap( \"map-usa.svg\", function () { map.loadCSS(\"style.css\", function () { map.addLayer(\"graticule\"); map.addLayer(\"graticule_1\"); map.addLayer(\"usa\"); $.getJSON(\"us-crime-cities.json\", function (crimeCities) { $.each(crimeCities, function (i, city) { $.each([\"ViolentCrime\", \"Rape\", \"Murder\"], function (i, prop) { $.each([\"2011\", \"2010\"], function (i, yr) { city[prop + yr + \"Rate\"] = city[prop + yr] / city.Population; }); }); }); updateMap = function () { var prop = $(\".dataset.btn-primary\").data(\"val\") + $(\".year.btn-primary\").html() + $(\".type.btn-primary\").data(\"val\"), maxRad = $(\".type.btn-primary\").data(\"maxrad\"); scale = kartograph.scale.linear(crimeCities, prop); $.each(crimeCities, function (i, c) { var bar, pts; pts = [c.ll, [c.ll[0], c.ll[1], scale(c[prop]) * maxRad]]; if (symbols[i]) { bar = symbols[i]; if (Raphael.svg) bar.animate({ path: map.getGeoPathStr(pts) }, 500); else bar.attr(\"path\", map.getGeoPathStr(pts)); } else { bar = map.addGeoPath([c.ll, c.ll]); bar.attr({ stroke: \"#024\", opacity: 0.6, \"stroke-width\": 4, fill: \"none\", \"stroke-linecap\": \"square\", }); if (Raphael.svg) { bar.animate({ path: map.getGeoPathStr(pts) }, 500); bar.node.setAttribute(\"title\", c.City); setTimeout(function () { $(bar.node).qtip( { content: { title: c.City, text: c[prop], }, position: { target: \"mouse\", viewport: $(window), adjust: { x: 7, y: 7 }, }, }, 800 ); }); } else { bar.attr(\"path\", map.getGeoPathStr(pts)); } symbols.push(bar); } }); }; updateMap(); }); }); }, { padding: -150 } ); $(\".btn\").click(function (event) { var tgt = $(event.target), par = tgt.parent(); $(\".btn\", par).removeClass(\"btn-primary\"); tgt.addClass(\"btn-primary\"); updateMap(); }); }); This map shows crime data for some cities in the United States. You can choose between showing actual quantities of incidents or the rates. Note that the purpose of this demo is not to promote 3D bar charts (which are fairly ineffective), but to showcase the satellite projection along with the possibility to project three dimensional geo-coordinates. In fact, the height of the bars in this example is given in km above ground. Violent Crime Rape Murder 2011 2010 Quantity Density","link":"/test_files/Three-dimensional-map.html"},{"title":"","text":"中国木版年画集成桃花坞卷上 body { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; } .bar { border: 1px solid #0b3536; border-radius: 6px; fill: #0098d8; } #bar .barText { fill: #f5faf8; font-weight: 500; } .axisY text, .axisX text, .headerText text { fill: #0b3536; } #bar svg { background-color: #f5faf8; } /** V4柱状图初始化 **/ function BarInit(width, height, rectHeight, rectPadding, padding, data) { // 获取x轴的数据 var Xdatas = data.map(function (d) { return d.key; }); // 获取y轴的数据 var values = data.map(function (d) { return d.value; }); // 创建X,Y轴比例尺 var xScale = d3 .scaleBand() .domain(Xdatas) .rangeRound([0, width]) .padding(0.1), yScale = d3 .scaleLinear() .domain([0, d3.max(values)]) .rangeRound([height, 0]); // 将svg容器添加到Dom中 var svg = d3 .select(\"#bar\") .append(\"svg\") .attr(\"width\", width + padding.left + padding.right) .attr(\"height\", height + padding.top + padding.bottom); // 将group元素添加到svg容器中 var g = svg .append(\"g\") .attr( \"transform\", \"translate(\" + padding.left + \",\" + padding.top + \")\" ); // 添加图表的表头 g.attr(\"class\", \"headerText\") .append(\"text\") .attr( \"transform\", \"translate(\" + width / 2 + \",\" + -padding.top / 2 + \")\" ) .attr(\"text-anchor\", \"middle\") .attr(\"font-weight\", 600) .text(\"中国木版年画集成桃花坞卷上\"); // 添加X轴 g.append(\"g\") .attr(\"class\", \"axisX\") .attr(\"transform\", \"translate(0,\" + height + \")\") .call(d3.axisBottom(xScale)) .attr(\"font-weight\", \"bold\"); // 添加Y轴 g.append(\"g\") .attr(\"class\", \"axisY\") .call(d3.axisLeft(yScale).ticks(10)); // 创建盛放矩形的容器 var chart = g.selectAll(\".bar\").data(data).enter().append(\"g\"); // 添加矩形元素 chart .append(\"rect\") .attr(\"class\", \"bar\") .attr(\"x\", function (d) { return xScale(d.key); }) //动画开始 .attr(\"y\", function (d) { var min = yScale.domain()[0]; return yScale(min); }) .attr(\"height\", function (d) { return 0; }) .transition() .delay(function (d, i) { return i * 200; }) .duration(2000) .ease(d3.easeBounceIn) //动画结束 .attr(\"y\", function (d) { return yScale(d.value); }) .attr(\"height\", function (d) { return height - yScale(d.value); }) .attr(\"width\", xScale.bandwidth()); // 添加矩形内提示文字 chart .append(\"text\") .attr(\"class\", \"barText\") .attr(\"x\", function (d) { return xScale(d.key); }) //动画开始 .attr(\"y\", function (d) { var min = yScale.domain()[0]; return yScale(min); }) .attr(\"height\", function (d) { return 0; }) .transition() .delay(function (d, i) { return i * 200; }) .duration(1000) .ease(d3.easeBounceIn) //动画结束 .attr(\"y\", function (d) { return yScale(d.value); }) .attr(\"dx\", xScale.bandwidth() / 2) .attr(\"dy\", 20) .attr(\"text-anchor\", \"middle\") .text(function (d) { console.log(\"d.value\", d.value); return d.value; }); // 添加hover事件 chart .on(\"mouseover\", function (d) { d3.select(this).attr(\"opacity\", 0.7); }) .on(\"mouseout\", function (d) { d3.select(this).transition().duration(500).attr(\"opacity\", 1); }); } const padding = { top: 50, right: 20, bottom: 30, left: 30, }; const width = 1600 - padding.left - padding.right; const height = 600 - padding.top - padding.bottom; const rectHeight = 25; //每个矩形所占的像素高度(包括空白) const rectPadding = 4; //矩形之间的空白 var data = [ { key: \"清朝中期\", value: 66, }, { key: \"清朝晚期\", value: 69, }, { key: \"北宋\", value: 1, }, { key: \"明代\", value: 1, }, { key: \"南宋\", value: 1, }, { key: \"明朝\", value: 1, }, { key: \"民国时期\", value: 1, }, { key: \"清末民初\", value: 11, }, { key: \"不详\", value: 7, }, ]; //数据 BarInit(width, height, rectHeight, rectPadding, padding, data);","link":"/test_files/dynamic_animation.html"},{"title":"","text":"path { fill: none; stroke-linejoin: round; stroke-linecap: round; } .graticule { fill: none; stroke: #777; } .boundary { fill: #ccc; fill-opacity: 0.8; stroke: #000; } .land-fill { stroke: #40053f; stroke-width: 4px; } .state-boundary { stroke: #40053f; stroke-width: 3px; } .county-boundary { fill: #ffebcd; stroke-dasharray: 5, 3, 9, 2; stroke: #7b0c4c; stroke-width: 0.5px; } .routes { stroke-dasharray: 2, 4, 5, 3; } .statenames { font: 20px/1.4 \"Helvetica Neue\", Arial, Helvetica, sans-serif; } .statenameshalo { font: 20px/1.4 \"Helvetica Neue\", Arial, Helvetica, sans-serif; stroke: white; stroke-width: 3px; fill: white; opacity: 0.5; } var width = 960, height = 960; scaleVal = 12500; distanceVal = 1.11; rotateVal = 30; clipVal = 15; countyColors = [\"#f0b103\", \"#ffb202\", \"#f6b623\", \"#ffbc02\", \"#ffb215\"]; projection = d3.geo .satellite() .distance(distanceVal) .scale(scaleVal) .rotate([121.0, -35.5, 20]) .center([-4, 5]) .tilt(60) .clipAngle(clipVal); var graticule = d3.geo .graticule() .extent([ [-135, 24], [-66, 55], ]) .step([1, 1]); path = d3.geo.path().projection(projection); var svg = d3 .select(\"body\") .append(\"svg\") .attr(\"width\", width) .attr(\"height\", height); svg .append(\"path\") .datum(graticule) .attr(\"class\", \"graticule\") .attr(\"d\", path); d3.json(\"us.json\", function (error, us) { svg .append(\"path\") // solid white fill .datum(topojson.mesh(us, us.objects.land)) .attr(\"d\", path) .attr(\"class\", \"land-fill\"); svg .selectAll(\".county\") .data(topojson.object(us, us.objects.counties).geometries) .enter() .insert(\"path\") .attr(\"class\", \"county-boundary\") .attr(\"d\", path) .style(\"fill\", function (d, i) { return countyColors[i % 5]; }) .on(\"mouseover\", function (d) { d3.select(this) .transition() .duration(500) .style(\"stroke-width\", 5) .style(\"stroke-opacity\", 0.5); }) .on(\"mouseout\", function () { d3.select(this) .transition() .duration(500) .style(\"stroke-width\", 0.5) .style(\"stroke-opacity\", 1); }); svg .append(\"path\") // thick grey stroke for internal state boundaries .datum( topojson.mesh(us, us.objects.states, function (a, b) { return a.id !== b.id; }) ) .attr(\"d\", path) .attr(\"class\", \"state-boundary\"); sampleData = [ { name: \"San Francisco\", coordinates: [-122.417, 37.783], barheight: 100, }, { name: \"Sacramento\", coordinates: [-121.505, 40.488], barheight: 30 }, { name: \"Portland\", coordinates: [-122.682, 45.52], barheight: 50 }, ]; bars = svg .selectAll(\"g\") .data(sampleData) .enter() .append(\"g\") .attr(\"class\", \"bars\") .attr(\"transform\", function (d) { return \"translate(\" + projection(d.coordinates) + \")\"; }); bars .append(\"rect\") .attr(\"height\", function (d) { return d.barheight; }) .attr(\"width\", 10) .attr(\"y\", function (d) { return -d.barheight; }) .attr(\"class\", \"bars\") .style(\"fill\", \"purple\") .style(\"stroke\", \"white\") .style(\"stroke-width\", 2); bars .append(\"text\") .text(function (d) { return d.name; }) .attr(\"x\", -10) .attr(\"y\", 18); bars.transition().duration(500).style(\"opacity\", 1); svg .selectAll(\"text.statenameshalo\") .data([\"Oregon\", \"California\"]) .enter() .append(\"text\") .text(function (d) { return d; }) .attr(\"x\", 390) .attr(\"y\", function (d, i) { return 328 + i * 33; }) .attr(\"class\", \"statenameshalo\") .attr(\"transform\", \"rotate(-15)\"); svg .selectAll(\"text.statenames\") .data([\"Oregon\", \"California\"]) .enter() .append(\"text\") .text(function (d) { return d; }) .attr(\"x\", 390) .attr(\"y\", function (d, i) { return 328 + i * 33; }) .attr(\"class\", \"statenames\") .attr(\"transform\", \"rotate(-15)\"); }); d3.select(self.frameElement).style(\"height\", height + \"px\");","link":"/test_files/dynamic_d3_3d.html"},{"title":"","text":"import { Box2, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Matrix3, Path, Shape, ShapePath, ShapeUtils, Vector2, Vector3 } from 'three'; class SVGLoader extends Loader { constructor( manager ) { super( manager ); // Default dots per inch this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px' this.defaultUnit = 'px'; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( text ) { const scope = this; function parseNode( node, style ) { if ( node.nodeType !== 1 ) return; const transform = getNodeTransform( node ); let isDefsNode = false; let path = null; switch ( node.nodeName ) { case 'svg': style = parseStyle( node, style ); break; case 'style': parseCSSStylesheet( node ); break; case 'g': style = parseStyle( node, style ); break; case 'path': style = parseStyle( node, style ); if ( node.hasAttribute( 'd' ) ) path = parsePathNode( node ); break; case 'rect': style = parseStyle( node, style ); path = parseRectNode( node ); break; case 'polygon': style = parseStyle( node, style ); path = parsePolygonNode( node ); break; case 'polyline': style = parseStyle( node, style ); path = parsePolylineNode( node ); break; case 'circle': style = parseStyle( node, style ); path = parseCircleNode( node ); break; case 'ellipse': style = parseStyle( node, style ); path = parseEllipseNode( node ); break; case 'line': style = parseStyle( node, style ); path = parseLineNode( node ); break; case 'defs': isDefsNode = true; break; case 'use': style = parseStyle( node, style ); const href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || ''; const usedNodeId = href.substring( 1 ); const usedNode = node.viewportElement.getElementById( usedNodeId ); if ( usedNode ) { parseNode( usedNode, style ); } else { console.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId ); } break; default: // console.log( node ); } if ( path ) { if ( style.fill !== undefined && style.fill !== 'none' ) { path.color.setStyle( style.fill ); } transformPath( path, currentTransform ); paths.push( path ); path.userData = { node: node, style: style }; } const childNodes = node.childNodes; for ( let i = 0; i < childNodes.length; i ++ ) { const node = childNodes[ i ]; if ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) { // Ignore everything in defs except CSS style definitions // and nested defs, because it is OK by the standard to have // there. continue; } parseNode( node, style ); } if ( transform ) { transformStack.pop(); if ( transformStack.length > 0 ) { currentTransform.copy( transformStack[ transformStack.length - 1 ] ); } else { currentTransform.identity(); } } } function parsePathNode( node ) { const path = new ShapePath(); const point = new Vector2(); const control = new Vector2(); const firstPoint = new Vector2(); let isFirstPoint = true; let doSetFirstPoint = false; const d = node.getAttribute( 'd' ); // console.log( d ); const commands = d.match( /[a-df-z][^a-df-z]*/ig ); for ( let i = 0, l = commands.length; i < l; i ++ ) { const command = commands[ i ]; const type = command.charAt( 0 ); const data = command.slice( 1 ).trim(); if ( isFirstPoint === true ) { doSetFirstPoint = true; isFirstPoint = false; } let numbers; switch ( type ) { case 'M': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x = numbers[ j + 0 ]; point.y = numbers[ j + 1 ]; control.x = point.x; control.y = point.y; if ( j === 0 ) { path.moveTo( point.x, point.y ); } else { path.lineTo( point.x, point.y ); } if ( j === 0 ) firstPoint.copy( point ); } break; case 'H': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.x = numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'V': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.y = numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'L': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x = numbers[ j + 0 ]; point.y = numbers[ j + 1 ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'C': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) { path.bezierCurveTo( numbers[ j + 0 ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], numbers[ j + 5 ] ); control.x = numbers[ j + 2 ]; control.y = numbers[ j + 3 ]; point.x = numbers[ j + 4 ]; point.y = numbers[ j + 5 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'S': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.bezierCurveTo( getReflection( point.x, control.x ), getReflection( point.y, control.y ), numbers[ j + 0 ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ] ); control.x = numbers[ j + 0 ]; control.y = numbers[ j + 1 ]; point.x = numbers[ j + 2 ]; point.y = numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'Q': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.quadraticCurveTo( numbers[ j + 0 ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ] ); control.x = numbers[ j + 0 ]; control.y = numbers[ j + 1 ]; point.x = numbers[ j + 2 ]; point.y = numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'T': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { const rx = getReflection( point.x, control.x ); const ry = getReflection( point.y, control.y ); path.quadraticCurveTo( rx, ry, numbers[ j + 0 ], numbers[ j + 1 ] ); control.x = rx; control.y = ry; point.x = numbers[ j + 0 ]; point.y = numbers[ j + 1 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'A': numbers = parseFloats( data, [ 3, 4 ], 7 ); for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) { // skip command if start point == end point if ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue; const start = point.clone(); point.x = numbers[ j + 5 ]; point.y = numbers[ j + 6 ]; control.x = point.x; control.y = point.y; parseArcCommand( path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'm': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x += numbers[ j + 0 ]; point.y += numbers[ j + 1 ]; control.x = point.x; control.y = point.y; if ( j === 0 ) { path.moveTo( point.x, point.y ); } else { path.lineTo( point.x, point.y ); } if ( j === 0 ) firstPoint.copy( point ); } break; case 'h': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.x += numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'v': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.y += numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'l': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x += numbers[ j + 0 ]; point.y += numbers[ j + 1 ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'c': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) { path.bezierCurveTo( point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ], point.x + numbers[ j + 2 ], point.y + numbers[ j + 3 ], point.x + numbers[ j + 4 ], point.y + numbers[ j + 5 ] ); control.x = point.x + numbers[ j + 2 ]; control.y = point.y + numbers[ j + 3 ]; point.x += numbers[ j + 4 ]; point.y += numbers[ j + 5 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 's': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.bezierCurveTo( getReflection( point.x, control.x ), getReflection( point.y, control.y ), point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ], point.x + numbers[ j + 2 ], point.y + numbers[ j + 3 ] ); control.x = point.x + numbers[ j + 0 ]; control.y = point.y + numbers[ j + 1 ]; point.x += numbers[ j + 2 ]; point.y += numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'q': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.quadraticCurveTo( point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ], point.x + numbers[ j + 2 ], point.y + numbers[ j + 3 ] ); control.x = point.x + numbers[ j + 0 ]; control.y = point.y + numbers[ j + 1 ]; point.x += numbers[ j + 2 ]; point.y += numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 't': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { const rx = getReflection( point.x, control.x ); const ry = getReflection( point.y, control.y ); path.quadraticCurveTo( rx, ry, point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ] ); control.x = rx; control.y = ry; point.x = point.x + numbers[ j + 0 ]; point.y = point.y + numbers[ j + 1 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'a': numbers = parseFloats( data, [ 3, 4 ], 7 ); for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) { // skip command if no displacement if ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue; const start = point.clone(); point.x += numbers[ j + 5 ]; point.y += numbers[ j + 6 ]; control.x = point.x; control.y = point.y; parseArcCommand( path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'Z': case 'z': path.currentPath.autoClose = true; if ( path.currentPath.curves.length > 0 ) { // Reset point to beginning of Path point.copy( firstPoint ); path.currentPath.currentPoint.copy( point ); isFirstPoint = true; } break; default: console.warn( command ); } // console.log( type, parseFloats( data ), parseFloats( data ).length ) doSetFirstPoint = false; } return path; } function parseCSSStylesheet( node ) { if ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return; for ( let i = 0; i < node.sheet.cssRules.length; i ++ ) { const stylesheet = node.sheet.cssRules[ i ]; if ( stylesheet.type !== 1 ) continue; const selectorList = stylesheet.selectorText .split( /,/gm ) .filter( Boolean ) .map( i => i.trim() ); for ( let j = 0; j < selectorList.length; j ++ ) { // Remove empty rules const definitions = Object.fromEntries( Object.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' ) ); stylesheets[ selectorList[ j ] ] = Object.assign( stylesheets[ selectorList[ j ] ] || {}, definitions ); } } } /** * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion * From * rx ry x-axis-rotation large-arc-flag sweep-flag x y * To * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation */ function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) { if ( rx == 0 || ry == 0 ) { // draw a line if either of the radii == 0 path.lineTo( end.x, end.y ); return; } x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive rx = Math.abs( rx ); ry = Math.abs( ry ); // Compute (x1', y1') const dx2 = ( start.x - end.x ) / 2.0; const dy2 = ( start.y - end.y ) / 2.0; const x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2; const y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2; // Compute (cx', cy') let rxs = rx * rx; let rys = ry * ry; const x1ps = x1p * x1p; const y1ps = y1p * y1p; // Ensure radii are large enough const cr = x1ps / rxs + y1ps / rys; if ( cr > 1 ) { // scale up rx,ry equally so cr == 1 const s = Math.sqrt( cr ); rx = s * rx; ry = s * ry; rxs = rx * rx; rys = ry * ry; } const dq = ( rxs * y1ps + rys * x1ps ); const pq = ( rxs * rys - dq ) / dq; let q = Math.sqrt( Math.max( 0, pq ) ); if ( large_arc_flag === sweep_flag ) q = - q; const cxp = q * rx * y1p / ry; const cyp = - q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy') const cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2; const cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2; // Step 4: Compute θ1 and Δθ const theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry ); const delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 ); path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation ); } function svgAngle( ux, uy, vx, vy ) { const dot = ux * vx + uy * vy; const len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy ); let ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang; return ang; } /* * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough */ function parseRectNode( node ) { const x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 ); const y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 ); const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 ); const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 ); const w = parseFloatWithUnits( node.getAttribute( 'width' ) ); const h = parseFloatWithUnits( node.getAttribute( 'height' ) ); // Ellipse arc to Bezier approximation Coefficient (Inversed). See: // https://spencermortensen.com/articles/bezier-circle/ const bci = 1 - 0.551915024494; const path = new ShapePath(); // top left path.moveTo( x + rx, y ); // top right path.lineTo( x + w - rx, y ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry ); } // bottom right path.lineTo( x + w, y + h - ry ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h ); } // bottom left path.lineTo( x + rx, y + h ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry ); } // back to top left path.lineTo( x, y + ry ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y ); } return path; } function parsePolygonNode( node ) { function iterator( match, a, b ) { const x = parseFloatWithUnits( a ); const y = parseFloatWithUnits( b ); if ( index === 0 ) { path.moveTo( x, y ); } else { path.lineTo( x, y ); } index ++; } const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g; const path = new ShapePath(); let index = 0; node.getAttribute( 'points' ).replace( regex, iterator ); path.currentPath.autoClose = true; return path; } function parsePolylineNode( node ) { function iterator( match, a, b ) { const x = parseFloatWithUnits( a ); const y = parseFloatWithUnits( b ); if ( index === 0 ) { path.moveTo( x, y ); } else { path.lineTo( x, y ); } index ++; } const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g; const path = new ShapePath(); let index = 0; node.getAttribute( 'points' ).replace( regex, iterator ); path.currentPath.autoClose = false; return path; } function parseCircleNode( node ) { const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 ); const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 ); const r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 ); const subpath = new Path(); subpath.absarc( x, y, r, 0, Math.PI * 2 ); const path = new ShapePath(); path.subPaths.push( subpath ); return path; } function parseEllipseNode( node ) { const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 ); const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 ); const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 ); const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 ); const subpath = new Path(); subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 ); const path = new ShapePath(); path.subPaths.push( subpath ); return path; } function parseLineNode( node ) { const x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 ); const y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 ); const x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 ); const y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 ); const path = new ShapePath(); path.moveTo( x1, y1 ); path.lineTo( x2, y2 ); path.currentPath.autoClose = false; return path; } // function parseStyle( node, style ) { style = Object.assign( {}, style ); // clone style let stylesheetStyles = {}; if ( node.hasAttribute( 'class' ) ) { const classSelectors = node.getAttribute( 'class' ) .split( /\\s/ ) .filter( Boolean ) .map( i => i.trim() ); for ( let i = 0; i < classSelectors.length; i ++ ) { stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] ); } } if ( node.hasAttribute( 'id' ) ) { stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] ); } function addStyle( svgName, jsName, adjustFunction ) { if ( adjustFunction === undefined ) adjustFunction = function copy( v ) { if ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' ); return v; }; if ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) ); if ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] ); if ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] ); } function clamp( v ) { return Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) ); } function positive( v ) { return Math.max( 0, parseFloatWithUnits( v ) ); } addStyle( 'fill', 'fill' ); addStyle( 'fill-opacity', 'fillOpacity', clamp ); addStyle( 'fill-rule', 'fillRule' ); addStyle( 'opacity', 'opacity', clamp ); addStyle( 'stroke', 'stroke' ); addStyle( 'stroke-opacity', 'strokeOpacity', clamp ); addStyle( 'stroke-width', 'strokeWidth', positive ); addStyle( 'stroke-linejoin', 'strokeLineJoin' ); addStyle( 'stroke-linecap', 'strokeLineCap' ); addStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive ); addStyle( 'visibility', 'visibility' ); return style; } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes function getReflection( a, b ) { return a - ( b - a ); } // from https://github.com/ppvg/svg-numbers (MIT License) function parseFloats( input, flags, stride ) { if ( typeof input !== 'string' ) { throw new TypeError( 'Invalid input: ' + typeof input ); } // Character groups const RE = { SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/, WHITESPACE: /[ \\t\\r\\n]/, DIGIT: /[\\d]/, SIGN: /[-+]/, POINT: /\\./, COMMA: /,/, EXP: /e/i, FLAGS: /[01]/ }; // States const SEP = 0; const INT = 1; const FLOAT = 2; const EXP = 3; let state = SEP; let seenComma = true; let number = '', exponent = ''; const result = []; function throwSyntaxError( current, i, partial ) { const error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' ); error.partial = partial; throw error; } function newNumber() { if ( number !== '' ) { if ( exponent === '' ) result.push( Number( number ) ); else result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) ); } number = ''; exponent = ''; } let current; const length = input.length; for ( let i = 0; i < length; i ++ ) { current = input[ i ]; // check for flags if ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) { state = INT; number = current; newNumber(); continue; } // parse until next number if ( state === SEP ) { // eat whitespace if ( RE.WHITESPACE.test( current ) ) { continue; } // start new number if ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) { state = INT; number = current; continue; } if ( RE.POINT.test( current ) ) { state = FLOAT; number = current; continue; } // throw on double commas (e.g. \"1, , 2\") if ( RE.COMMA.test( current ) ) { if ( seenComma ) { throwSyntaxError( current, i, result ); } seenComma = true; } } // parse integer part if ( state === INT ) { if ( RE.DIGIT.test( current ) ) { number += current; continue; } if ( RE.POINT.test( current ) ) { number += current; state = FLOAT; continue; } if ( RE.EXP.test( current ) ) { state = EXP; continue; } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\") if ( RE.SIGN.test( current ) && number.length === 1 && RE.SIGN.test( number[ 0 ] ) ) { throwSyntaxError( current, i, result ); } } // parse decimal part if ( state === FLOAT ) { if ( RE.DIGIT.test( current ) ) { number += current; continue; } if ( RE.EXP.test( current ) ) { state = EXP; continue; } // throw on double decimal points (e.g. \"1..2\") if ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) { throwSyntaxError( current, i, result ); } } // parse exponent part if ( state === EXP ) { if ( RE.DIGIT.test( current ) ) { exponent += current; continue; } if ( RE.SIGN.test( current ) ) { if ( exponent === '' ) { exponent += current; continue; } if ( exponent.length === 1 && RE.SIGN.test( exponent ) ) { throwSyntaxError( current, i, result ); } } } // end of number if ( RE.WHITESPACE.test( current ) ) { newNumber(); state = SEP; seenComma = false; } else if ( RE.COMMA.test( current ) ) { newNumber(); state = SEP; seenComma = true; } else if ( RE.SIGN.test( current ) ) { newNumber(); state = INT; number = current; } else if ( RE.POINT.test( current ) ) { newNumber(); state = FLOAT; number = current; } else { throwSyntaxError( current, i, result ); } } // add the last number found (if any) newNumber(); return result; } // Units const units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ]; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent) const unitConversion = { 'mm': { 'mm': 1, 'cm': 0.1, 'in': 1 / 25.4, 'pt': 72 / 25.4, 'pc': 6 / 25.4, 'px': - 1 }, 'cm': { 'mm': 10, 'cm': 1, 'in': 1 / 2.54, 'pt': 72 / 2.54, 'pc': 6 / 2.54, 'px': - 1 }, 'in': { 'mm': 25.4, 'cm': 2.54, 'in': 1, 'pt': 72, 'pc': 6, 'px': - 1 }, 'pt': { 'mm': 25.4 / 72, 'cm': 2.54 / 72, 'in': 1 / 72, 'pt': 1, 'pc': 6 / 72, 'px': - 1 }, 'pc': { 'mm': 25.4 / 6, 'cm': 2.54 / 6, 'in': 1 / 6, 'pt': 72 / 6, 'pc': 1, 'px': - 1 }, 'px': { 'px': 1 } }; function parseFloatWithUnits( string ) { let theUnit = 'px'; if ( typeof string === 'string' || string instanceof String ) { for ( let i = 0, n = units.length; i < n; i ++ ) { const u = units[ i ]; if ( string.endsWith( u ) ) { theUnit = u; string = string.substring( 0, string.length - u.length ); break; } } } let scale = undefined; if ( theUnit === 'px' && scope.defaultUnit !== 'px' ) { // Conversion scale from pixels to inches, then to default units scale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI; } else { scale = unitConversion[ theUnit ][ scope.defaultUnit ]; if ( scale < 0 ) { // Conversion scale to pixels scale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI; } } return scale * parseFloat( string ); } // Transforms function getNodeTransform( node ) { if ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) { return null; } const transform = parseNodeTransform( node ); if ( transformStack.length > 0 ) { transform.premultiply( transformStack[ transformStack.length - 1 ] ); } currentTransform.copy( transform ); transformStack.push( transform ); return transform; } function parseNodeTransform( node ) { const transform = new Matrix3(); const currentTransform = tempTransform0; if ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) { const tx = parseFloatWithUnits( node.getAttribute( 'x' ) ); const ty = parseFloatWithUnits( node.getAttribute( 'y' ) ); transform.translate( tx, ty ); } if ( node.hasAttribute( 'transform' ) ) { const transformsTexts = node.getAttribute( 'transform' ).split( ')' ); for ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) { const transformText = transformsTexts[ tIndex ].trim(); if ( transformText === '' ) continue; const openParPos = transformText.indexOf( '(' ); const closeParPos = transformText.length; if ( openParPos > 0 && openParPos < closeParPos ) { const transformType = transformText.slice( 0, openParPos ); const array = parseFloats( transformText.slice( openParPos + 1 ) ); currentTransform.identity(); switch ( transformType ) { case 'translate': if ( array.length >= 1 ) { const tx = array[ 0 ]; let ty = tx; if ( array.length >= 2 ) { ty = array[ 1 ]; } currentTransform.translate( tx, ty ); } break; case 'rotate': if ( array.length >= 1 ) { let angle = 0; let cx = 0; let cy = 0; // Angle angle = - array[ 0 ] * Math.PI / 180; if ( array.length >= 3 ) { // Center x, y cx = array[ 1 ]; cy = array[ 2 ]; } // Rotate around center (cx, cy) tempTransform1.identity().translate( - cx, - cy ); tempTransform2.identity().rotate( angle ); tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 ); tempTransform1.identity().translate( cx, cy ); currentTransform.multiplyMatrices( tempTransform1, tempTransform3 ); } break; case 'scale': if ( array.length >= 1 ) { const scaleX = array[ 0 ]; let scaleY = scaleX; if ( array.length >= 2 ) { scaleY = array[ 1 ]; } currentTransform.scale( scaleX, scaleY ); } break; case 'skewX': if ( array.length === 1 ) { currentTransform.set( 1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0, 0, 1, 0, 0, 0, 1 ); } break; case 'skewY': if ( array.length === 1 ) { currentTransform.set( 1, 0, 0, Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0, 0, 0, 1 ); } break; case 'matrix': if ( array.length === 6 ) { currentTransform.set( array[ 0 ], array[ 2 ], array[ 4 ], array[ 1 ], array[ 3 ], array[ 5 ], 0, 0, 1 ); } break; } } transform.premultiply( currentTransform ); } } return transform; } function transformPath( path, m ) { function transfVec2( v2 ) { tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m ); v2.set( tempV3.x, tempV3.y ); } const isRotated = isTransformRotated( m ); const subPaths = path.subPaths; for ( let i = 0, n = subPaths.length; i < n; i ++ ) { const subPath = subPaths[ i ]; const curves = subPath.curves; for ( let j = 0; j < curves.length; j ++ ) { const curve = curves[ j ]; if ( curve.isLineCurve ) { transfVec2( curve.v1 ); transfVec2( curve.v2 ); } else if ( curve.isCubicBezierCurve ) { transfVec2( curve.v0 ); transfVec2( curve.v1 ); transfVec2( curve.v2 ); transfVec2( curve.v3 ); } else if ( curve.isQuadraticBezierCurve ) { transfVec2( curve.v0 ); transfVec2( curve.v1 ); transfVec2( curve.v2 ); } else if ( curve.isEllipseCurve ) { if ( isRotated ) { console.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' ); } tempV2.set( curve.aX, curve.aY ); transfVec2( tempV2 ); curve.aX = tempV2.x; curve.aY = tempV2.y; curve.xRadius *= getTransformScaleX( m ); curve.yRadius *= getTransformScaleY( m ); } } } } function isTransformRotated( m ) { return m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0; } function getTransformScaleX( m ) { const te = m.elements; return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] ); } function getTransformScaleY( m ) { const te = m.elements; return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] ); } // const paths = []; const stylesheets = {}; const transformStack = []; const tempTransform0 = new Matrix3(); const tempTransform1 = new Matrix3(); const tempTransform2 = new Matrix3(); const tempTransform3 = new Matrix3(); const tempV2 = new Vector2(); const tempV3 = new Vector3(); const currentTransform = new Matrix3(); const xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml parseNode( xml.documentElement, { fill: '#000', fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeLineJoin: 'miter', strokeLineCap: 'butt', strokeMiterLimit: 4 } ); const data = { paths: paths, xml: xml.documentElement }; // console.log( paths ); return data; } static createShapes( shapePath ) { // Param shapePath: a shapepath as returned by the parse function of this class // Returns Shape object const BIGNUMBER = 999999999; const IntersectionLocationType = { ORIGIN: 0, DESTINATION: 1, BETWEEN: 2, LEFT: 3, RIGHT: 4, BEHIND: 5, BEYOND: 6 }; const classifyResult = { loc: IntersectionLocationType.ORIGIN, t: 0 }; function findEdgeIntersection( a0, a1, b0, b1 ) { const x1 = a0.x; const x2 = a1.x; const x3 = b0.x; const x4 = b1.x; const y1 = a0.y; const y2 = a1.y; const y3 = b0.y; const y4 = b1.y; const nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 ); const nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 ); const denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 ); const t1 = nom1 / denom; const t2 = nom2 / denom; if ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 = 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) { //1. lines are parallel or edges don't intersect return null; } else if ( ( nom1 === 0 ) && ( denom === 0 ) ) { //2. lines are colinear //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1) for ( let i = 0; i < 2; i ++ ) { classifyPoint( i === 0 ? b0 : b1, a0, a1 ); //find position of this endpoints relatively to edge1 if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) { const point = ( i === 0 ? b0 : b1 ); return { x: point.x, y: point.y, t: classifyResult.t }; } else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) { const x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) ); const y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) ); return { x: x, y: y, t: classifyResult.t, }; } } return null; } else { //3. edges intersect for ( let i = 0; i < 2; i ++ ) { classifyPoint( i === 0 ? b0 : b1, a0, a1 ); if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) { const point = ( i === 0 ? b0 : b1 ); return { x: point.x, y: point.y, t: classifyResult.t }; } } const x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) ); const y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) ); return { x: x, y: y, t: t1 }; } } function classifyPoint( p, edgeStart, edgeEnd ) { const ax = edgeEnd.x - edgeStart.x; const ay = edgeEnd.y - edgeStart.y; const bx = p.x - edgeStart.x; const by = p.y - edgeStart.y; const sa = ax * by - bx * ay; if ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) { classifyResult.loc = IntersectionLocationType.ORIGIN; classifyResult.t = 0; return; } if ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) { classifyResult.loc = IntersectionLocationType.DESTINATION; classifyResult.t = 1; return; } if ( sa < - Number.EPSILON ) { classifyResult.loc = IntersectionLocationType.LEFT; return; } if ( sa > Number.EPSILON ) { classifyResult.loc = IntersectionLocationType.RIGHT; return; } if ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) { classifyResult.loc = IntersectionLocationType.BEHIND; return; } if ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) { classifyResult.loc = IntersectionLocationType.BEYOND; return; } let t; if ( ax !== 0 ) { t = bx / ax; } else { t = by / ay; } classifyResult.loc = IntersectionLocationType.BETWEEN; classifyResult.t = t; } function getIntersections( path1, path2 ) { const intersectionsRaw = []; const intersections = []; for ( let index = 1; index < path1.length; index ++ ) { const path1EdgeStart = path1[ index - 1 ]; const path1EdgeEnd = path1[ index ]; for ( let index2 = 1; index2 < path2.length; index2 ++ ) { const path2EdgeStart = path2[ index2 - 1 ]; const path2EdgeEnd = path2[ index2 ]; const intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd ); if ( intersection !== null && intersectionsRaw.find( i => i.t = intersection.t - Number.EPSILON ) === undefined ) { intersectionsRaw.push( intersection ); intersections.push( new Vector2( intersection.x, intersection.y ) ); } } } return intersections; } function getScanlineIntersections( scanline, boundingBox, paths ) { const center = new Vector2(); boundingBox.getCenter( center ); const allIntersections = []; paths.forEach( path => { // check if the center of the bounding box is in the bounding box of the paths. // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path. // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path. if ( path.boundingBox.containsPoint( center ) ) { const intersections = getIntersections( scanline, path.points ); intersections.forEach( p => { allIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } ); } ); } } ); allIntersections.sort( ( i1, i2 ) => { return i1.point.x - i2.point.x; } ); return allIntersections; } function isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) { if ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) { _fillRule = 'nonzero'; } const centerBoundingBox = new Vector2(); simplePath.boundingBox.getCenter( centerBoundingBox ); const scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ]; const scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths ); scanlineIntersections.sort( ( i1, i2 ) => { return i1.point.x - i2.point.x; } ); const baseIntersections = []; const otherIntersections = []; scanlineIntersections.forEach( i => { if ( i.identifier === simplePath.identifier ) { baseIntersections.push( i ); } else { otherIntersections.push( i ); } } ); const firstXOfPath = baseIntersections[ 0 ].point.x; // build up the path hierarchy const stack = []; let i = 0; while ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) { if ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) { stack.pop(); } else { stack.push( otherIntersections[ i ].identifier ); } i ++; } stack.push( simplePath.identifier ); if ( _fillRule === 'evenodd' ) { const isHole = stack.length % 2 === 0 ? true : false; const isHoleFor = stack[ stack.length - 2 ]; return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }; } else if ( _fillRule === 'nonzero' ) { // check if path is a hole by counting the amount of paths with alternating rotations it has to cross. let isHole = true; let isHoleFor = null; let lastCWValue = null; for ( let i = 0; i < stack.length; i ++ ) { const identifier = stack[ i ]; if ( isHole ) { lastCWValue = allPaths[ identifier ].isCW; isHole = false; isHoleFor = identifier; } else if ( lastCWValue !== allPaths[ identifier ].isCW ) { lastCWValue = allPaths[ identifier ].isCW; isHole = true; } } return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }; } else { console.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' ); } } // check for self intersecting paths // TODO // check intersecting paths // TODO // prepare paths for hole detection let identifier = 0; let scanlineMinX = BIGNUMBER; let scanlineMaxX = - BIGNUMBER; let simplePaths = shapePath.subPaths.map( p => { const points = p.getPoints(); let maxY = - BIGNUMBER; let minY = BIGNUMBER; let maxX = - BIGNUMBER; let minX = BIGNUMBER; //points.forEach(p => p.y *= -1); for ( let i = 0; i < points.length; i ++ ) { const p = points[ i ]; if ( p.y > maxY ) { maxY = p.y; } if ( p.y < minY ) { minY = p.y; } if ( p.x > maxX ) { maxX = p.x; } if ( p.x < minX ) { minX = p.x; } } // if ( scanlineMaxX = minX ) { scanlineMinX = minX - 1; } return { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) }; } ); simplePaths = simplePaths.filter( sp => sp.points.length > 1 ); // check if path is solid or a hole const isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) ); const shapesToReturn = []; simplePaths.forEach( p => { const amIAHole = isAHole[ p.identifier ]; if ( ! amIAHole.isHole ) { const shape = new Shape(); shape.curves = p.curves; const holes = isAHole.filter( h => h.isHole && h.for === p.identifier ); holes.forEach( h => { const hole = simplePaths[ h.identifier ]; const path = new Path(); path.curves = hole.curves; shape.holes.push( path ); } ); shapesToReturn.push( shape ); } } ); return shapesToReturn; } static getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) { // Param width: Stroke width // Param color: As returned by THREE.Color.getStyle() // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\" // Param lineCap: One of \"round\", \"square\" or \"butt\" // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance) // Returns style object width = width !== undefined ? width : 1; color = color !== undefined ? color : '#000'; lineJoin = lineJoin !== undefined ? lineJoin : 'miter'; lineCap = lineCap !== undefined ? lineCap : 'butt'; miterLimit = miterLimit !== undefined ? miterLimit : 4; return { strokeColor: color, strokeWidth: width, strokeLineJoin: lineJoin, strokeLineCap: lineCap, strokeMiterLimit: miterLimit }; } static pointsToStroke( points, style, arcDivisions, minDistance ) { // Generates a stroke with some witdh around the given path. // The path can be open or closed (last point equals to first point) // Param points: Array of Vector2D (the path). Minimum 2 points. // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional) // Param minDistance: Points closer to this distance will be merged. (Optional) // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right) const vertices = []; const normals = []; const uvs = []; if ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) { return null; } const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); return geometry; } static pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) { // This function can be called to update existing arrays or buffers. // Accepts same parameters as pointsToStroke, plus the buffers and optional offset. // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs) // Returns number of written vertices / normals / uvs pairs // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers) // 'normals' and 'uvs' buffers are optional const tempV2_1 = new Vector2(); const tempV2_2 = new Vector2(); const tempV2_3 = new Vector2(); const tempV2_4 = new Vector2(); const tempV2_5 = new Vector2(); const tempV2_6 = new Vector2(); const tempV2_7 = new Vector2(); const lastPointL = new Vector2(); const lastPointR = new Vector2(); const point0L = new Vector2(); const point0R = new Vector2(); const currentPointL = new Vector2(); const currentPointR = new Vector2(); const nextPointL = new Vector2(); const nextPointR = new Vector2(); const innerPoint = new Vector2(); const outerPoint = new Vector2(); arcDivisions = arcDivisions !== undefined ? arcDivisions : 12; minDistance = minDistance !== undefined ? minDistance : 0.001; vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points points = removeDuplicatedPoints( points ); const numPoints = points.length; if ( numPoints < 2 ) return 0; const isClosed = points[ 0 ].equals( points[ numPoints - 1 ] ); let currentPoint; let previousPoint = points[ 0 ]; let nextPoint; const strokeWidth2 = style.strokeWidth / 2; const deltaU = 1 / ( numPoints - 1 ); let u0 = 0, u1; let innerSideModified; let joinIsOnLeftSide; let isMiter; let initialJoinIsOnLeftSide = false; let numVertices = 0; let currentCoordinate = vertexOffset * 3; let currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points getNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 ); lastPointL.copy( points[ 0 ] ).sub( tempV2_1 ); lastPointR.copy( points[ 0 ] ).add( tempV2_1 ); point0L.copy( lastPointL ); point0R.copy( lastPointR ); for ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) { currentPoint = points[ iPoint ]; // Get next point if ( iPoint === numPoints - 1 ) { if ( isClosed ) { // Skip duplicated initial point nextPoint = points[ 1 ]; } else nextPoint = undefined; } else { nextPoint = points[ iPoint + 1 ]; } // Normal of previous segment in tempV2_1 const normal1 = tempV2_1; getNormal( previousPoint, currentPoint, normal1 ); tempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 ); currentPointL.copy( currentPoint ).sub( tempV2_3 ); currentPointR.copy( currentPoint ).add( tempV2_3 ); u1 = u0 + deltaU; innerSideModified = false; if ( nextPoint !== undefined ) { // Normal of next segment in tempV2_2 getNormal( currentPoint, nextPoint, tempV2_2 ); tempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 ); nextPointL.copy( currentPoint ).sub( tempV2_3 ); nextPointR.copy( currentPoint ).add( tempV2_3 ); joinIsOnLeftSide = true; tempV2_3.subVectors( nextPoint, previousPoint ); if ( normal1.dot( tempV2_3 ) < 0 ) { joinIsOnLeftSide = false; } if ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide; tempV2_3.subVectors( nextPoint, currentPoint ); tempV2_3.normalize(); const dot = Math.abs( normal1.dot( tempV2_3 ) ); // If path is straight, don't create join if ( dot !== 0 ) { // Compute inner and outer segment intersections const miterSide = strokeWidth2 / dot; tempV2_3.multiplyScalar( - miterSide ); tempV2_4.subVectors( currentPoint, previousPoint ); tempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 ); innerPoint.copy( tempV2_5 ).negate(); const miterLength2 = tempV2_5.length(); const segmentLengthPrev = tempV2_4.length(); tempV2_4.divideScalar( segmentLengthPrev ); tempV2_6.subVectors( nextPoint, currentPoint ); const segmentLengthNext = tempV2_6.length(); tempV2_6.divideScalar( segmentLengthNext ); // Check that previous and next segments doesn't overlap with the innerPoint of intersection if ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) { innerSideModified = true; } outerPoint.copy( tempV2_5 ).add( currentPoint ); innerPoint.add( currentPoint ); isMiter = false; if ( innerSideModified ) { if ( joinIsOnLeftSide ) { nextPointR.copy( innerPoint ); currentPointR.copy( innerPoint ); } else { nextPointL.copy( innerPoint ); currentPointL.copy( innerPoint ); } } else { // The segment triangles are generated here if there was overlapping makeSegmentTriangles(); } switch ( style.strokeLineJoin ) { case 'bevel': makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 ); break; case 'round': // Segment triangles createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ); // Join triangles if ( joinIsOnLeftSide ) { makeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 ); } else { makeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 ); } break; case 'miter': case 'miter-clip': default: const miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2; if ( miterFraction < 1 ) { // The join miter length exceeds the miter limit if ( style.strokeLineJoin !== 'miter-clip' ) { makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 ); break; } else { // Segment triangles createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ); // Miter-clip join triangles if ( joinIsOnLeftSide ) { tempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL ); tempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL ); addVertex( currentPointL, u1, 0 ); addVertex( tempV2_6, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_6, u1, 0 ); addVertex( tempV2_7, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_7, u1, 0 ); addVertex( nextPointL, u1, 0 ); } else { tempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR ); tempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR ); addVertex( currentPointR, u1, 1 ); addVertex( tempV2_6, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_6, u1, 1 ); addVertex( tempV2_7, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_7, u1, 1 ); addVertex( nextPointR, u1, 1 ); } } } else { // Miter join segment triangles if ( innerSideModified ) { // Optimized segment + join triangles if ( joinIsOnLeftSide ) { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( outerPoint, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( outerPoint, u1, 0 ); addVertex( innerPoint, u1, 1 ); } else { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( outerPoint, u1, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( innerPoint, u1, 0 ); addVertex( outerPoint, u1, 1 ); } if ( joinIsOnLeftSide ) { nextPointL.copy( outerPoint ); } else { nextPointR.copy( outerPoint ); } } else { // Add extra miter join triangles if ( joinIsOnLeftSide ) { addVertex( currentPointL, u1, 0 ); addVertex( outerPoint, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( outerPoint, u1, 0 ); addVertex( nextPointL, u1, 0 ); } else { addVertex( currentPointR, u1, 1 ); addVertex( outerPoint, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( outerPoint, u1, 1 ); addVertex( nextPointR, u1, 1 ); } } isMiter = true; } break; } } else { // The segment triangles are generated here when two consecutive points are collinear makeSegmentTriangles(); } } else { // The segment triangles are generated here if it is the ending segment makeSegmentTriangles(); } if ( ! isClosed && iPoint === numPoints - 1 ) { // Start line endcap addCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 ); } // Increment loop variables u0 = u1; previousPoint = currentPoint; lastPointL.copy( nextPointL ); lastPointR.copy( nextPointR ); } if ( ! isClosed ) { // Ending line endcap addCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 ); } else if ( innerSideModified && vertices ) { // Modify path first segment vertices to adjust to the segments inner and outer intersections let lastOuter = outerPoint; let lastInner = innerPoint; if ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) { lastOuter = innerPoint; lastInner = outerPoint; } if ( joinIsOnLeftSide ) { if ( isMiter || initialJoinIsOnLeftSide ) { lastInner.toArray( vertices, 0 * 3 ); lastInner.toArray( vertices, 3 * 3 ); if ( isMiter ) { lastOuter.toArray( vertices, 1 * 3 ); } } } else { if ( isMiter || ! initialJoinIsOnLeftSide ) { lastInner.toArray( vertices, 1 * 3 ); lastInner.toArray( vertices, 3 * 3 ); if ( isMiter ) { lastOuter.toArray( vertices, 0 * 3 ); } } } } return numVertices; // -- End of algorithm // -- Functions function getNormal( p1, p2, result ) { result.subVectors( p2, p1 ); return result.set( - result.y, result.x ).normalize(); } function addVertex( position, u, v ) { if ( vertices ) { vertices[ currentCoordinate ] = position.x; vertices[ currentCoordinate + 1 ] = position.y; vertices[ currentCoordinate + 2 ] = 0; if ( normals ) { normals[ currentCoordinate ] = 0; normals[ currentCoordinate + 1 ] = 0; normals[ currentCoordinate + 2 ] = 1; } currentCoordinate += 3; if ( uvs ) { uvs[ currentCoordinateUV ] = u; uvs[ currentCoordinateUV + 1 ] = v; currentCoordinateUV += 2; } } numVertices += 3; } function makeCircularSector( center, p1, p2, u, v ) { // param p1, p2: Points in the circle arc. // p1 and p2 are in clockwise direction. tempV2_1.copy( p1 ).sub( center ).normalize(); tempV2_2.copy( p2 ).sub( center ).normalize(); let angle = Math.PI; const dot = tempV2_1.dot( tempV2_2 ); if ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) ); angle /= arcDivisions; tempV2_3.copy( p1 ); for ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) { tempV2_4.copy( tempV2_3 ).rotateAround( center, angle ); addVertex( tempV2_3, u, v ); addVertex( tempV2_4, u, v ); addVertex( center, u, 0.5 ); tempV2_3.copy( tempV2_4 ); } addVertex( tempV2_4, u, v ); addVertex( p2, u, v ); addVertex( center, u, 0.5 ); } function makeSegmentTriangles() { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointL, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( currentPointL, u1, 1 ); addVertex( currentPointR, u1, 0 ); } function makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) { if ( innerSideModified ) { // Optimized segment + bevel triangles if ( joinIsOnLeftSide ) { // Path segments triangles addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointL, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( currentPointL, u1, 0 ); addVertex( innerPoint, u1, 1 ); // Bevel join triangle addVertex( currentPointL, u, 0 ); addVertex( nextPointL, u, 0 ); addVertex( innerPoint, u, 0.5 ); } else { // Path segments triangles addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointR, u1, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( innerPoint, u1, 0 ); addVertex( currentPointR, u1, 1 ); // Bevel join triangle addVertex( currentPointR, u, 1 ); addVertex( nextPointR, u, 0 ); addVertex( innerPoint, u, 0.5 ); } } else { // Bevel join triangle. The segment triangles are done in the main loop if ( joinIsOnLeftSide ) { addVertex( currentPointL, u, 0 ); addVertex( nextPointL, u, 0 ); addVertex( currentPoint, u, 0.5 ); } else { addVertex( currentPointR, u, 1 ); addVertex( nextPointR, u, 0 ); addVertex( currentPoint, u, 0.5 ); } } } function createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) { if ( innerSideModified ) { if ( joinIsOnLeftSide ) { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointL, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( currentPointL, u1, 0 ); addVertex( innerPoint, u1, 1 ); addVertex( currentPointL, u0, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( innerPoint, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( nextPointL, u0, 0 ); addVertex( innerPoint, u1, 1 ); } else { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointR, u1, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( innerPoint, u1, 0 ); addVertex( currentPointR, u1, 1 ); addVertex( currentPointR, u0, 1 ); addVertex( innerPoint, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( innerPoint, u1, 0 ); addVertex( nextPointR, u0, 1 ); } } } function addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) { // param center: End point of the path // param p1, p2: Left and right cap points switch ( style.strokeLineCap ) { case 'round': if ( start ) { makeCircularSector( center, p2, p1, u, 0.5 ); } else { makeCircularSector( center, p1, p2, u, 0.5 ); } break; case 'square': if ( start ) { tempV2_1.subVectors( p1, center ); tempV2_2.set( tempV2_1.y, - tempV2_1.x ); tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center ); tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center ); // Modify already existing vertices if ( joinIsOnLeftSide ) { tempV2_3.toArray( vertices, 1 * 3 ); tempV2_4.toArray( vertices, 0 * 3 ); tempV2_4.toArray( vertices, 3 * 3 ); } else { tempV2_3.toArray( vertices, 1 * 3 ); tempV2_3.toArray( vertices, 3 * 3 ); tempV2_4.toArray( vertices, 0 * 3 ); } } else { tempV2_1.subVectors( p2, center ); tempV2_2.set( tempV2_1.y, - tempV2_1.x ); tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center ); tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center ); const vl = vertices.length; // Modify already existing vertices if ( joinIsOnLeftSide ) { tempV2_3.toArray( vertices, vl - 1 * 3 ); tempV2_4.toArray( vertices, vl - 2 * 3 ); tempV2_4.toArray( vertices, vl - 4 * 3 ); } else { tempV2_3.toArray( vertices, vl - 2 * 3 ); tempV2_4.toArray( vertices, vl - 1 * 3 ); tempV2_4.toArray( vertices, vl - 4 * 3 ); } } break; case 'butt': default: // Nothing to do here break; } } function removeDuplicatedPoints( points ) { // Creates a new array if necessary with duplicated points removed. // This does not remove duplicated initial and ending points of a closed path. let dupPoints = false; for ( let i = 1, n = points.length - 1; i < n; i ++ ) { if ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) { dupPoints = true; break; } } if ( ! dupPoints ) return points; const newPoints = []; newPoints.push( points[ 0 ] ); for ( let i = 1, n = points.length - 1; i < n; i ++ ) { if ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) { newPoints.push( points[ i ] ); } } newPoints.push( points[ points.length - 1 ] ); return newPoints; } } } export { SVGLoader };","link":"/test_files/SVGLoader.js"},{"title":"","text":"中国木版年画集成桃花坞卷上 * { margin: 0; padding: 0; } #chart-container { position: relative; height: 100vh; overflow: hidden; } var dom = document.getElementById(\"chart-container\"); var myChart = echarts.init(dom, null, { renderer: \"canvas\", useDirtyRect: false, }); var app = {}; var option; var data = [ { name: \"清朝中期\", children: [ { name: \"清•雍正十二年（1734年）\", value: 2, }, { name: \"清•乾隆五年（1740年）\", value: 1, }, { name: \"清•乾隆九年（1744年）\", value: 1, }, { name: \"清•乾隆\", value: 25, }, { name: \"清中期\", value: 21, }, { name: \"清•雍正、乾隆\", value: 1, }, { name: \"清•咸丰\", value: 1, }, { name: \"清•嘉庆\", value: 2, }, { name: \"清•康熙\", value: 11, }, { name: \"清•乾隆八年\", value: 1, }, ], }, { name: \"清朝晚期\", children: [ { name: \"清•咸丰\", value: 1, }, { name: \"清晚期\", value: 29, }, { name: \"清•光绪\", value: 6, }, { name: \"清末\", value: 31, }, { name: \"清•道光\", value: 1, }, { name: \"清•道光\", value: 1, }, ], }, { name: \"北宋\", children: [ { name: \"北宋\", value: 1, }, ], }, { name: \"明代\", children: [ { name: \"明代\", value: 1, }, ], }, { name: \"南宋\", children: [ { name: \"南宋绍定二年\", value: 1, }, ], }, { name: \"明朝\", children: [ { name: \"明•万历二十五年（1597年）\", value: 1, }, ], }, { name: \"民国时期\", children: [ { name: \"民国\", value: 1, }, ], }, { name: \"清末民初\", children: [ { name: \"清末民初\", value: 10, }, { name: \"清末明初\", value: 1, }, ], }, { name: \"不详\", children: [ { name: \"清代\", value: 5, }, { name: \"清早中期\", value: 1, }, { name: \"清代中晚期\", value: 1, }, ], }, ]; option = { visualMap: { type: \"continuous\", min: 0, max: 10, inRange: { color: [\"#FFAE57\", \"#FF7853\", \"#EA5151\", \"#CC3F57\", \"#9A2555\"], }, }, series: { type: \"sunburst\", data: data, radius: [0, \"90%\"], label: { rotate: \"radial\", }, }, }; if (option && typeof option === \"object\") { myChart.setOption(option); } window.addEventListener(\"resize\", myChart.resize);","link":"/test_files/dynamic_pic.html"},{"title":"","text":"path { stroke: #fff; } var width = 960, height = 700, radius = Math.min(width, height) / 2 - 10; var formatNumber = d3.format(\",d\"); var x = d3.scale.linear().range([0, 2 * Math.PI]); var y = d3.scale.sqrt().range([0, radius]); var color = d3.scale.category20c(); var partition = d3.layout.partition().value(function (d) { return d.size; }); var arc = d3.svg .arc() .startAngle(function (d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); }) .endAngle(function (d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); }) .innerRadius(function (d) { return Math.max(0, y(d.y)); }) .outerRadius(function (d) { return Math.max(0, y(d.y + d.dy)); }); var svg = d3 .select(\"body\") .append(\"svg\") .attr(\"width\", width) .attr(\"height\", height) .append(\"g\") .attr(\"transform\", \"translate(\" + width / 2 + \",\" + height / 2 + \")\"); d3.json(\"flare.json\", function (error, root) { if (error) throw error; svg .selectAll(\"path\") .data(partition.nodes(root)) .enter() .append(\"path\") .attr(\"d\", arc) .style(\"fill\", function (d) { return color((d.children ? d : d.parent).name); }) .on(\"click\", click) .append(\"title\") .text(function (d) { return d.name + \"\\n\" + formatNumber(d.value); }); }); function click(d) { svg .transition() .duration(750) .tween(\"scale\", function () { var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]), yd = d3.interpolate(y.domain(), [d.y, 1]), yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]); return function (t) { x.domain(xd(t)); y.domain(yd(t)).range(yr(t)); }; }) .selectAll(\"path\") .attrTween(\"d\", function (d) { return function () { return arc(d); }; }); } d3.select(self.frameElement).style(\"height\", height + \"px\");","link":"/test_files/dynamic_pic_d3.html"},{"title":"","text":"","link":"/test_files/time_line_d3.html"},{"title":"","text":"{\"name\":\"flare\",\"children\":[{\"name\":\"analytics\",\"children\":[{\"name\":\"测试\",\"children\":[{\"name\":\"AgglomerativeCluster\",\"size\":3938},{\"name\":\"CommunityStructure\",\"size\":3812},{\"name\":\"HierarchicalCluster\",\"size\":6714},{\"name\":\"MergeEdge\",\"size\":743}]},{\"name\":\"graph\",\"children\":[{\"name\":\"BetweennessCentrality\",\"size\":3534},{\"name\":\"LinkDistance\",\"size\":5731},{\"name\":\"MaxFlowMinCut\",\"size\":7840},{\"name\":\"ShortestPaths\",\"size\":5914},{\"name\":\"SpanningTree\",\"size\":3416}]},{\"name\":\"optimization\",\"children\":[{\"name\":\"AspectRatioBanker\",\"size\":7074}]}]},{\"name\":\"animate\",\"children\":[{\"name\":\"Easing\",\"size\":17010},{\"name\":\"FunctionSequence\",\"size\":5842},{\"name\":\"interpolate\",\"children\":[{\"name\":\"ArrayInterpolator\",\"size\":1983},{\"name\":\"ColorInterpolator\",\"size\":2047},{\"name\":\"DateInterpolator\",\"size\":1375},{\"name\":\"Interpolator\",\"size\":8746},{\"name\":\"MatrixInterpolator\",\"size\":2202},{\"name\":\"NumberInterpolator\",\"size\":1382},{\"name\":\"ObjectInterpolator\",\"size\":1629},{\"name\":\"PointInterpolator\",\"size\":1675},{\"name\":\"RectangleInterpolator\",\"size\":2042}]},{\"name\":\"ISchedulable\",\"size\":1041},{\"name\":\"Parallel\",\"size\":5176},{\"name\":\"Pause\",\"size\":449},{\"name\":\"Scheduler\",\"size\":5593},{\"name\":\"Sequence\",\"size\":5534},{\"name\":\"Transition\",\"size\":9201},{\"name\":\"Transitioner\",\"size\":19975},{\"name\":\"TransitionEvent\",\"size\":1116},{\"name\":\"Tween\",\"size\":6006}]},{\"name\":\"data\",\"children\":[{\"name\":\"converters\",\"children\":[{\"name\":\"Converters\",\"size\":721},{\"name\":\"DelimitedTextConverter\",\"size\":4294},{\"name\":\"GraphMLConverter\",\"size\":9800},{\"name\":\"IDataConverter\",\"size\":1314},{\"name\":\"JSONConverter\",\"size\":2220}]},{\"name\":\"DataField\",\"size\":1759},{\"name\":\"DataSchema\",\"size\":2165},{\"name\":\"DataSet\",\"size\":586},{\"name\":\"DataSource\",\"size\":3331},{\"name\":\"DataTable\",\"size\":772},{\"name\":\"DataUtil\",\"size\":3322}]},{\"name\":\"display\",\"children\":[{\"name\":\"DirtySprite\",\"size\":8833},{\"name\":\"LineSprite\",\"size\":1732},{\"name\":\"RectSprite\",\"size\":3623},{\"name\":\"TextSprite\",\"size\":10066}]},{\"name\":\"flex\",\"children\":[{\"name\":\"FlareVis\",\"size\":4116}]},{\"name\":\"physics\",\"children\":[{\"name\":\"DragForce\",\"size\":1082},{\"name\":\"GravityForce\",\"size\":1336},{\"name\":\"IForce\",\"size\":319},{\"name\":\"NBodyForce\",\"size\":10498},{\"name\":\"Particle\",\"size\":2822},{\"name\":\"Simulation\",\"size\":9983},{\"name\":\"Spring\",\"size\":2213},{\"name\":\"SpringForce\",\"size\":1681}]},{\"name\":\"query\",\"children\":[{\"name\":\"AggregateExpression\",\"size\":1616},{\"name\":\"And\",\"size\":1027},{\"name\":\"Arithmetic\",\"size\":3891},{\"name\":\"Average\",\"size\":891},{\"name\":\"BinaryExpression\",\"size\":2893},{\"name\":\"Comparison\",\"size\":5103},{\"name\":\"CompositeExpression\",\"size\":3677},{\"name\":\"Count\",\"size\":781},{\"name\":\"DateUtil\",\"size\":4141},{\"name\":\"Distinct\",\"size\":933},{\"name\":\"Expression\",\"size\":5130},{\"name\":\"ExpressionIterator\",\"size\":3617},{\"name\":\"Fn\",\"size\":3240},{\"name\":\"If\",\"size\":2732},{\"name\":\"IsA\",\"size\":2039},{\"name\":\"Literal\",\"size\":1214},{\"name\":\"Match\",\"size\":3748},{\"name\":\"Maximum\",\"size\":843},{\"name\":\"methods\",\"children\":[{\"name\":\"add\",\"size\":593},{\"name\":\"and\",\"size\":330},{\"name\":\"average\",\"size\":287},{\"name\":\"count\",\"size\":277},{\"name\":\"distinct\",\"size\":292},{\"name\":\"div\",\"size\":595},{\"name\":\"eq\",\"size\":594},{\"name\":\"fn\",\"size\":460},{\"name\":\"gt\",\"size\":603},{\"name\":\"gte\",\"size\":625},{\"name\":\"iff\",\"size\":748},{\"name\":\"isa\",\"size\":461},{\"name\":\"lt\",\"size\":597},{\"name\":\"lte\",\"size\":619},{\"name\":\"max\",\"size\":283},{\"name\":\"min\",\"size\":283},{\"name\":\"mod\",\"size\":591},{\"name\":\"mul\",\"size\":603},{\"name\":\"neq\",\"size\":599},{\"name\":\"not\",\"size\":386},{\"name\":\"or\",\"size\":323},{\"name\":\"orderby\",\"size\":307},{\"name\":\"range\",\"size\":772},{\"name\":\"select\",\"size\":296},{\"name\":\"stddev\",\"size\":363},{\"name\":\"sub\",\"size\":600},{\"name\":\"sum\",\"size\":280},{\"name\":\"update\",\"size\":307},{\"name\":\"variance\",\"size\":335},{\"name\":\"where\",\"size\":299},{\"name\":\"xor\",\"size\":354},{\"name\":\"_\",\"size\":264}]},{\"name\":\"Minimum\",\"size\":843},{\"name\":\"Not\",\"size\":1554},{\"name\":\"Or\",\"size\":970},{\"name\":\"Query\",\"size\":13896},{\"name\":\"Range\",\"size\":1594},{\"name\":\"StringUtil\",\"size\":4130},{\"name\":\"Sum\",\"size\":791},{\"name\":\"Variable\",\"size\":1124},{\"name\":\"Variance\",\"size\":1876},{\"name\":\"Xor\",\"size\":1101}]},{\"name\":\"scale\",\"children\":[{\"name\":\"IScaleMap\",\"size\":2105},{\"name\":\"LinearScale\",\"size\":1316},{\"name\":\"LogScale\",\"size\":3151},{\"name\":\"OrdinalScale\",\"size\":3770},{\"name\":\"QuantileScale\",\"size\":2435},{\"name\":\"QuantitativeScale\",\"size\":4839},{\"name\":\"RootScale\",\"size\":1756},{\"name\":\"Scale\",\"size\":4268},{\"name\":\"ScaleType\",\"size\":1821},{\"name\":\"TimeScale\",\"size\":5833}]},{\"name\":\"util\",\"children\":[{\"name\":\"Arrays\",\"size\":8258},{\"name\":\"Colors\",\"size\":10001},{\"name\":\"Dates\",\"size\":8217},{\"name\":\"Displays\",\"size\":12555},{\"name\":\"Filter\",\"size\":2324},{\"name\":\"Geometry\",\"size\":10993},{\"name\":\"heap\",\"children\":[{\"name\":\"FibonacciHeap\",\"size\":9354},{\"name\":\"HeapNode\",\"size\":1233}]},{\"name\":\"IEvaluable\",\"size\":335},{\"name\":\"IPredicate\",\"size\":383},{\"name\":\"IValueProxy\",\"size\":874},{\"name\":\"math\",\"children\":[{\"name\":\"DenseMatrix\",\"size\":3165},{\"name\":\"IMatrix\",\"size\":2815},{\"name\":\"SparseMatrix\",\"size\":3366}]},{\"name\":\"Maths\",\"size\":17705},{\"name\":\"Orientation\",\"size\":1486},{\"name\":\"palette\",\"children\":[{\"name\":\"ColorPalette\",\"size\":6367},{\"name\":\"Palette\",\"size\":1229},{\"name\":\"ShapePalette\",\"size\":2059},{\"name\":\"SizePalette\",\"size\":2291}]},{\"name\":\"Property\",\"size\":5559},{\"name\":\"Shapes\",\"size\":19118},{\"name\":\"Sort\",\"size\":6887},{\"name\":\"Stats\",\"size\":6557},{\"name\":\"Strings\",\"size\":22026}]},{\"name\":\"vis\",\"children\":[{\"name\":\"axis\",\"children\":[{\"name\":\"Axes\",\"size\":1302},{\"name\":\"Axis\",\"size\":24593},{\"name\":\"AxisGridLine\",\"size\":652},{\"name\":\"AxisLabel\",\"size\":636},{\"name\":\"CartesianAxes\",\"size\":6703}]},{\"name\":\"controls\",\"children\":[{\"name\":\"AnchorControl\",\"size\":2138},{\"name\":\"ClickControl\",\"size\":3824},{\"name\":\"Control\",\"size\":1353},{\"name\":\"ControlList\",\"size\":4665},{\"name\":\"DragControl\",\"size\":2649},{\"name\":\"ExpandControl\",\"size\":2832},{\"name\":\"HoverControl\",\"size\":4896},{\"name\":\"IControl\",\"size\":763},{\"name\":\"PanZoomControl\",\"size\":5222},{\"name\":\"SelectionControl\",\"size\":7862},{\"name\":\"TooltipControl\",\"size\":8435}]},{\"name\":\"data\",\"children\":[{\"name\":\"Data\",\"size\":20544},{\"name\":\"DataList\",\"size\":19788},{\"name\":\"DataSprite\",\"size\":10349},{\"name\":\"EdgeSprite\",\"size\":3301},{\"name\":\"NodeSprite\",\"size\":19382},{\"name\":\"render\",\"children\":[{\"name\":\"ArrowType\",\"size\":698},{\"name\":\"EdgeRenderer\",\"size\":5569},{\"name\":\"IRenderer\",\"size\":353},{\"name\":\"ShapeRenderer\",\"size\":2247}]},{\"name\":\"ScaleBinding\",\"size\":11275},{\"name\":\"Tree\",\"size\":7147},{\"name\":\"TreeBuilder\",\"size\":9930}]},{\"name\":\"events\",\"children\":[{\"name\":\"DataEvent\",\"size\":2313},{\"name\":\"SelectionEvent\",\"size\":1880},{\"name\":\"TooltipEvent\",\"size\":1701},{\"name\":\"VisualizationEvent\",\"size\":1117}]},{\"name\":\"legend\",\"children\":[{\"name\":\"Legend\",\"size\":20859},{\"name\":\"LegendItem\",\"size\":4614},{\"name\":\"LegendRange\",\"size\":10530}]},{\"name\":\"operator\",\"children\":[{\"name\":\"distortion\",\"children\":[{\"name\":\"BifocalDistortion\",\"size\":4461},{\"name\":\"Distortion\",\"size\":6314},{\"name\":\"FisheyeDistortion\",\"size\":3444}]},{\"name\":\"encoder\",\"children\":[{\"name\":\"ColorEncoder\",\"size\":3179},{\"name\":\"Encoder\",\"size\":4060},{\"name\":\"PropertyEncoder\",\"size\":4138},{\"name\":\"ShapeEncoder\",\"size\":1690},{\"name\":\"SizeEncoder\",\"size\":1830}]},{\"name\":\"filter\",\"children\":[{\"name\":\"FisheyeTreeFilter\",\"size\":5219},{\"name\":\"GraphDistanceFilter\",\"size\":3165},{\"name\":\"VisibilityFilter\",\"size\":3509}]},{\"name\":\"IOperator\",\"size\":1286},{\"name\":\"label\",\"children\":[{\"name\":\"Labeler\",\"size\":9956},{\"name\":\"RadialLabeler\",\"size\":3899},{\"name\":\"StackedAreaLabeler\",\"size\":3202}]},{\"name\":\"layout\",\"children\":[{\"name\":\"AxisLayout\",\"size\":6725},{\"name\":\"BundledEdgeRouter\",\"size\":3727},{\"name\":\"CircleLayout\",\"size\":9317},{\"name\":\"CirclePackingLayout\",\"size\":12003},{\"name\":\"DendrogramLayout\",\"size\":4853},{\"name\":\"ForceDirectedLayout\",\"size\":8411},{\"name\":\"IcicleTreeLayout\",\"size\":4864},{\"name\":\"IndentedTreeLayout\",\"size\":3174},{\"name\":\"Layout\",\"size\":7881},{\"name\":\"NodeLinkTreeLayout\",\"size\":12870},{\"name\":\"PieLayout\",\"size\":2728},{\"name\":\"RadialTreeLayout\",\"size\":12348},{\"name\":\"RandomLayout\",\"size\":870},{\"name\":\"StackedAreaLayout\",\"size\":9121},{\"name\":\"TreeMapLayout\",\"size\":9191}]},{\"name\":\"Operator\",\"size\":2490},{\"name\":\"OperatorList\",\"size\":5248},{\"name\":\"OperatorSequence\",\"size\":4190},{\"name\":\"OperatorSwitch\",\"size\":2581},{\"name\":\"SortOperator\",\"size\":2023}]},{\"name\":\"Visualization\",\"size\":16540}]}]}","link":"/test_files/flare.json"},{"title":"","text":"{\"nodes\":[{\"character\":\"形成早期\",\"id\":0,\"influence\":30,\"zone\":0},{\"character\":\"手绘门神像\",\"id\":1,\"influence\":15,\"zone\":0},{\"character\":\"财神\",\"id\":2,\"influence\":24,\"zone\":3},{\"character\":\"福禄寿三星\",\"id\":3,\"influence\":18,\"zone\":3},{\"character\":\"关公\",\"id\":4,\"influence\":36,\"zone\":3},{\"character\":\"八仙\",\"id\":5,\"influence\":22,\"zone\":3},{\"character\":\"教化\",\"id\":6,\"influence\":12,\"zone\":0},{\"character\":\"戏文\",\"id\":7,\"influence\":7,\"zone\":3},{\"character\":\"金（敬）相邻\",\"id\":8,\"influence\":2,\"zone\":5},{\"character\":\"银（迎）亲眷\",\"id\":9,\"influence\":6,\"zone\":5},{\"character\":\"相互影响\",\"id\":10,\"influence\":14,\"zone\":2},{\"character\":\"明万历（1573-1619）\",\"id\":11,\"influence\":8,\"zone\":1},{\"character\":\"苏州古典园林\",\"id\":12,\"influence\":20,\"zone\":3},{\"character\":\"昆曲艺术\",\"id\":13,\"influence\":4,\"zone\":5},{\"character\":\"丝绸织物\",\"id\":14,\"influence\":12,\"zone\":3},{\"character\":\"工艺美术\",\"id\":15,\"influence\":18,\"zone\":3},{\"character\":\"财神\",\"id\":16,\"influence\":26,\"zone\":0},{\"character\":\"创新的印刷工艺出现\",\"id\":17,\"influence\":6,\"zone\":2},{\"character\":\"饾版\",\"id\":18,\"influence\":4,\"zone\":1},{\"character\":\"拱花\",\"id\":19,\"influence\":13,\"zone\":5},{\"character\":\"彩色套印\",\"id\":20,\"influence\":5,\"zone\":5},{\"character\":\"桃花坞早期\",\"id\":21,\"influence\":9,\"zone\":3},{\"character\":\"风格：市民化\",\"id\":22,\"influence\":6,\"zone\":6},{\"character\":\"姑苏万桥图\",\"id\":23,\"influence\":1,\"zone\":6},{\"character\":\"西方传教士和画家影响\",\"id\":24,\"influence\":4,\"zone\":2},{\"character\":\"日本浮世绘“姑苏版”\",\"id\":25,\"influence\":4,\"zone\":2},{\"character\":\"衰颓期：顿失\",\"id\":26,\"influence\":2,\"zone\":2},{\"character\":\"抢救、保护期（建国后）\",\"id\":27,\"influence\":5,\"zone\":2},{\"character\":\"挖掘\",\"id\":28,\"influence\":2,\"zone\":2},{\"character\":\"整理\",\"id\":29,\"influence\":4,\"zone\":2},{\"character\":\"抢救\",\"id\":30,\"influence\":5,\"zone\":3},{\"character\":\"1959 成立 苏州桃花坞木刻年画社\",\"id\":31,\"influence\":5,\"zone\":1},{\"character\":\"聘美术家\",\"id\":32,\"influence\":8,\"zone\":1},{\"character\":\"培养学徒\",\"id\":33,\"influence\":7,\"zone\":3},{\"character\":\"新年画\",\"id\":34,\"influence\":8,\"zone\":1},{\"character\":\"政治宣传（新式年画+宣传画）\",\"id\":35,\"influence\":3,\"zone\":1},{\"character\":\"文革：“四旧”\",\"id\":36,\"influence\":2,\"zone\":1},{\"character\":\"历史沿革\",\"id\":37,\"influence\":10,\"zone\":3},{\"character\":\"明代-清中晚期\",\"id\":38,\"influence\":7,\"zone\":3},{\"character\":\"苏州刻版（宋代）\",\"id\":39,\"influence\":25,\"zone\":1},{\"character\":\"徽派版刻\",\"id\":40,\"influence\":4,\"zone\":1},{\"character\":\"清末民初\",\"id\":41,\"influence\":26,\"zone\":3},{\"character\":\"太平天国\",\"id\":42,\"influence\":14,\"zone\":4},{\"character\":\"新中国\",\"id\":43,\"influence\":4,\"zone\":3},{\"character\":\"文人意趣\",\"id\":44,\"influence\":5,\"zone\":3},{\"character\":\"秾丽清透\",\"id\":45,\"influence\":6,\"zone\":3},{\"character\":\"文质沉雅\",\"id\":46,\"influence\":7,\"zone\":3},{\"character\":\"层次丰富\",\"id\":47,\"influence\":4,\"zone\":3},{\"character\":\"同治、光绪以后\",\"id\":48,\"influence\":5,\"zone\":3},{\"character\":\"西方合成颜料\",\"id\":49,\"influence\":7,\"zone\":3},{\"character\":\"节约成本\",\"id\":50,\"influence\":1,\"zone\":0},{\"character\":\"制工粗糙\",\"id\":51,\"influence\":4,\"zone\":6},{\"character\":\"斑驳凌乱\",\"id\":52,\"influence\":4,\"zone\":6},{\"character\":\"体裁\",\"id\":53,\"influence\":1,\"zone\":6},{\"character\":\"门画\",\"id\":54,\"influence\":4,\"zone\":6},{\"character\":\"中堂\",\"id\":55,\"influence\":4,\"zone\":6},{\"character\":\"条屏\",\"id\":56,\"influence\":6,\"zone\":6},{\"character\":\"斗方\",\"id\":57,\"influence\":1,\"zone\":6},{\"character\":\"连环画\",\"id\":58,\"influence\":2,\"zone\":6},{\"character\":\"纸马\",\"id\":59,\"influence\":1,\"zone\":6},{\"character\":\"装饰用纸\",\"id\":60,\"influence\":6,\"zone\":6},{\"character\":\"实用产品\",\"id\":61,\"influence\":3,\"zone\":6},{\"character\":\"规格\",\"id\":62,\"influence\":1,\"zone\":6},{\"character\":\"四尺宣的开数\",\"id\":63,\"influence\":1,\"zone\":4},{\"character\":\"整张\",\"id\":64,\"influence\":1,\"zone\":4},{\"character\":\"对开\",\"id\":65,\"influence\":19,\"zone\":5},{\"character\":\"三开\",\"id\":66,\"influence\":18,\"zone\":1},{\"character\":\"四开\",\"id\":67,\"influence\":5,\"zone\":0},{\"character\":\"八开\",\"id\":68,\"influence\":6,\"zone\":3},{\"character\":\"十二开\",\"id\":69,\"influence\":1,\"zone\":3},{\"character\":\"纸马\",\"id\":70,\"influence\":8,\"zone\":3},{\"character\":\"连环画\",\"id\":71,\"influence\":5,\"zone\":3},{\"character\":\"凌烟阁功臣图\",\"id\":72,\"influence\":3,\"zone\":0},{\"character\":\"御制耕织图\",\"id\":73,\"influence\":2,\"zone\":0},{\"character\":\"印刷术\",\"id\":74,\"influence\":6,\"zone\":3},{\"character\":\"雕版\",\"id\":75,\"influence\":7,\"zone\":3},{\"character\":\"始于宗教化\",\"id\":76,\"influence\":4,\"zone\":3},{\"character\":\"发展向印本书籍和风俗画\",\"id\":77,\"influence\":5,\"zone\":0},{\"character\":\"木版年画制作程序\",\"id\":78,\"influence\":3,\"zone\":0},{\"character\":\"绘\",\"id\":79,\"influence\":3,\"zone\":0},{\"character\":\"刻\",\"id\":80,\"influence\":4,\"zone\":0},{\"character\":\"印\",\"id\":81,\"influence\":6,\"zone\":0},{\"character\":\"桃花坞早期：模仿万历以后的版画\",\"id\":82,\"influence\":4,\"zone\":4},{\"character\":\"地图\",\"id\":83,\"influence\":1,\"zone\":0},{\"character\":\"风俗\",\"id\":84,\"influence\":5,\"zone\":0},{\"character\":\"历史故事\",\"id\":85,\"influence\":4,\"zone\":0},{\"character\":\"戏曲\",\"id\":86,\"influence\":2,\"zone\":0},{\"character\":\"仕女\",\"id\":87,\"influence\":4,\"zone\":0},{\"character\":\"花卉\",\"id\":88,\"influence\":4,\"zone\":0},{\"character\":\"文人画传统\",\"id\":89,\"influence\":1,\"zone\":3},{\"character\":\"苏州\",\"id\":90,\"influence\":2,\"zone\":3},{\"character\":\"桃花坞\",\"id\":91,\"influence\":3,\"zone\":3},{\"character\":\"清康\",\"id\":92,\"influence\":3,\"zone\":3},{\"character\":\"雍\",\"id\":93,\"influence\":5,\"zone\":4},{\"character\":\"乾\",\"id\":94,\"influence\":2,\"zone\":3},{\"character\":\"江\",\"id\":95,\"influence\":3,\"zone\":3},{\"character\":\"浙\",\"id\":96,\"influence\":1,\"zone\":1},{\"character\":\"皖\",\"id\":97,\"influence\":2,\"zone\":1},{\"character\":\"赣\",\"id\":98,\"influence\":2,\"zone\":3},{\"character\":\"鄂\",\"id\":99,\"influence\":1,\"zone\":3},{\"character\":\"鲁\",\"id\":100,\"influence\":4,\"zone\":3},{\"character\":\"豫\",\"id\":101,\"influence\":1,\"zone\":3},{\"character\":\"规格样式\",\"id\":102,\"influence\":14,\"zone\":6},{\"character\":\"南洋\",\"id\":103,\"influence\":12,\"zone\":5},{\"character\":\"城市生活\",\"id\":104,\"influence\":2,\"zone\":3},{\"character\":\"市民风俗\",\"id\":105,\"influence\":1,\"zone\":4},{\"character\":\"景物\",\"id\":106,\"influence\":1,\"zone\":3}],\"links\":[{\"source\":77,\"target\":0,\"weight\":5},{\"source\":77,\"target\":1,\"weight\":31},{\"source\":100,\"target\":2,\"weight\":18},{\"source\":100,\"target\":3,\"weight\":6},{\"source\":100,\"target\":4,\"weight\":5},{\"source\":100,\"target\":5,\"weight\":8},{\"source\":72,\"target\":6,\"weight\":5},{\"source\":101,\"target\":7,\"weight\":5},{\"source\":65,\"target\":8,\"weight\":11},{\"source\":65,\"target\":9,\"weight\":23},{\"source\":65,\"target\":10,\"weight\":9},{\"source\":65,\"target\":11,\"weight\":6},{\"source\":65,\"target\":12,\"weight\":5},{\"source\":65,\"target\":13,\"weight\":43},{\"source\":65,\"target\":14,\"weight\":7},{\"source\":65,\"target\":2,\"weight\":11},{\"source\":65,\"target\":15,\"weight\":6},{\"source\":65,\"target\":16,\"weight\":7},{\"source\":65,\"target\":17,\"weight\":8},{\"source\":65,\"target\":3,\"weight\":4},{\"source\":65,\"target\":18,\"weight\":5},{\"source\":65,\"target\":19,\"weight\":46},{\"source\":65,\"target\":20,\"weight\":18},{\"source\":65,\"target\":4,\"weight\":5},{\"source\":68,\"target\":21,\"weight\":4},{\"source\":54,\"target\":22,\"weight\":18},{\"source\":54,\"target\":23,\"weight\":10},{\"source\":9,\"target\":8,\"weight\":4},{\"source\":9,\"target\":13,\"weight\":4},{\"source\":9,\"target\":20,\"weight\":21},{\"source\":10,\"target\":24,\"weight\":96},{\"source\":10,\"target\":25,\"weight\":46},{\"source\":10,\"target\":16,\"weight\":12},{\"source\":10,\"target\":26,\"weight\":4},{\"source\":10,\"target\":27,\"weight\":54},{\"source\":10,\"target\":28,\"weight\":14},{\"source\":10,\"target\":17,\"weight\":35},{\"source\":10,\"target\":1,\"weight\":11},{\"source\":10,\"target\":29,\"weight\":11},{\"source\":33,\"target\":21,\"weight\":7},{\"source\":43,\"target\":14,\"weight\":5},{\"source\":43,\"target\":30,\"weight\":19},{\"source\":11,\"target\":31,\"weight\":4},{\"source\":11,\"target\":32,\"weight\":5},{\"source\":66,\"target\":10,\"weight\":4},{\"source\":66,\"target\":33,\"weight\":7},{\"source\":66,\"target\":11,\"weight\":8},{\"source\":66,\"target\":12,\"weight\":4},{\"source\":66,\"target\":34,\"weight\":16},{\"source\":66,\"target\":35,\"weight\":9},{\"source\":66,\"target\":2,\"weight\":19},{\"source\":66,\"target\":36,\"weight\":10},{\"source\":66,\"target\":37,\"weight\":8},{\"source\":66,\"target\":38,\"weight\":5},{\"source\":66,\"target\":39,\"weight\":43},{\"source\":66,\"target\":18,\"weight\":4},{\"source\":66,\"target\":40,\"weight\":6},{\"source\":66,\"target\":41,\"weight\":8},{\"source\":66,\"target\":42,\"weight\":4},{\"source\":66,\"target\":4,\"weight\":5},{\"source\":66,\"target\":32,\"weight\":19},{\"source\":12,\"target\":33,\"weight\":5},{\"source\":12,\"target\":43,\"weight\":4},{\"source\":12,\"target\":44,\"weight\":4},{\"source\":12,\"target\":14,\"weight\":6},{\"source\":12,\"target\":45,\"weight\":7},{\"source\":12,\"target\":2,\"weight\":36},{\"source\":12,\"target\":15,\"weight\":23},{\"source\":12,\"target\":46,\"weight\":10},{\"source\":12,\"target\":47,\"weight\":4},{\"source\":12,\"target\":3,\"weight\":16},{\"source\":12,\"target\":19,\"weight\":6},{\"source\":12,\"target\":48,\"weight\":4},{\"source\":12,\"target\":4,\"weight\":46},{\"source\":12,\"target\":49,\"weight\":4},{\"source\":67,\"target\":50,\"weight\":6},{\"source\":55,\"target\":51,\"weight\":4},{\"source\":55,\"target\":52,\"weight\":5},{\"source\":102,\"target\":53,\"weight\":8},{\"source\":102,\"target\":22,\"weight\":20},{\"source\":102,\"target\":54,\"weight\":26},{\"source\":102,\"target\":55,\"weight\":14},{\"source\":102,\"target\":51,\"weight\":18},{\"source\":102,\"target\":52,\"weight\":17},{\"source\":102,\"target\":56,\"weight\":47},{\"source\":102,\"target\":57,\"weight\":10},{\"source\":102,\"target\":58,\"weight\":26},{\"source\":102,\"target\":59,\"weight\":7},{\"source\":102,\"target\":60,\"weight\":12},{\"source\":102,\"target\":3,\"weight\":5},{\"source\":102,\"target\":61,\"weight\":8},{\"source\":102,\"target\":62,\"weight\":14},{\"source\":93,\"target\":63,\"weight\":4},{\"source\":93,\"target\":64,\"weight\":16},{\"source\":103,\"target\":65,\"weight\":18},{\"source\":103,\"target\":9,\"weight\":8},{\"source\":103,\"target\":10,\"weight\":15},{\"source\":103,\"target\":66,\"weight\":5},{\"source\":103,\"target\":12,\"weight\":6},{\"source\":103,\"target\":2,\"weight\":6},{\"source\":103,\"target\":16,\"weight\":8},{\"source\":103,\"target\":17,\"weight\":8},{\"source\":103,\"target\":39,\"weight\":13},{\"source\":103,\"target\":3,\"weight\":10},{\"source\":103,\"target\":19,\"weight\":5},{\"source\":103,\"target\":41,\"weight\":6},{\"source\":79,\"target\":0,\"weight\":8},{\"source\":34,\"target\":11,\"weight\":7},{\"source\":34,\"target\":31,\"weight\":4},{\"source\":34,\"target\":40,\"weight\":16},{\"source\":34,\"target\":32,\"weight\":9},{\"source\":13,\"target\":20,\"weight\":7},{\"source\":80,\"target\":67,\"weight\":17},{\"source\":14,\"target\":44,\"weight\":9},{\"source\":14,\"target\":45,\"weight\":7},{\"source\":14,\"target\":46,\"weight\":7},{\"source\":14,\"target\":7,\"weight\":24},{\"source\":14,\"target\":19,\"weight\":12},{\"source\":24,\"target\":25,\"weight\":35},{\"source\":24,\"target\":27,\"weight\":41},{\"source\":35,\"target\":34,\"weight\":9},{\"source\":52,\"target\":51,\"weight\":7},{\"source\":2,\"target\":68,\"weight\":6},{\"source\":2,\"target\":22,\"weight\":4},{\"source\":2,\"target\":33,\"weight\":88},{\"source\":2,\"target\":34,\"weight\":5},{\"source\":2,\"target\":44,\"weight\":4},{\"source\":2,\"target\":14,\"weight\":6},{\"source\":2,\"target\":15,\"weight\":15},{\"source\":2,\"target\":21,\"weight\":16},{\"source\":2,\"target\":46,\"weight\":11},{\"source\":2,\"target\":69,\"weight\":11},{\"source\":2,\"target\":70,\"weight\":7},{\"source\":2,\"target\":3,\"weight\":17},{\"source\":2,\"target\":42,\"weight\":5},{\"source\":2,\"target\":71,\"weight\":8},{\"source\":2,\"target\":4,\"weight\":31},{\"source\":81,\"target\":72,\"weight\":9},{\"source\":81,\"target\":73,\"weight\":5},{\"source\":81,\"target\":6,\"weight\":4},{\"source\":15,\"target\":14,\"weight\":5},{\"source\":15,\"target\":45,\"weight\":4},{\"source\":15,\"target\":74,\"weight\":8},{\"source\":15,\"target\":21,\"weight\":7},{\"source\":15,\"target\":75,\"weight\":28},{\"source\":15,\"target\":46,\"weight\":5},{\"source\":15,\"target\":76,\"weight\":5},{\"source\":15,\"target\":7,\"weight\":4},{\"source\":15,\"target\":19,\"weight\":14},{\"source\":15,\"target\":42,\"weight\":10},{\"source\":15,\"target\":71,\"weight\":9},{\"source\":15,\"target\":4,\"weight\":54},{\"source\":25,\"target\":27,\"weight\":33},{\"source\":25,\"target\":1,\"weight\":11},{\"source\":16,\"target\":77,\"weight\":30},{\"source\":16,\"target\":72,\"weight\":15},{\"source\":16,\"target\":67,\"weight\":7},{\"source\":16,\"target\":78,\"weight\":6},{\"source\":16,\"target\":79,\"weight\":4},{\"source\":16,\"target\":80,\"weight\":9},{\"source\":16,\"target\":0,\"weight\":25},{\"source\":16,\"target\":81,\"weight\":8},{\"source\":16,\"target\":6,\"weight\":69},{\"source\":16,\"target\":27,\"weight\":4},{\"source\":16,\"target\":82,\"weight\":7},{\"source\":16,\"target\":83,\"weight\":6},{\"source\":16,\"target\":84,\"weight\":31},{\"source\":16,\"target\":85,\"weight\":20},{\"source\":16,\"target\":3,\"weight\":5},{\"source\":16,\"target\":1,\"weight\":52},{\"source\":16,\"target\":42,\"weight\":9},{\"source\":16,\"target\":86,\"weight\":16},{\"source\":16,\"target\":29,\"weight\":8},{\"source\":16,\"target\":87,\"weight\":12},{\"source\":16,\"target\":88,\"weight\":54},{\"source\":104,\"target\":37,\"weight\":5},{\"source\":104,\"target\":3,\"weight\":6},{\"source\":56,\"target\":22,\"weight\":11},{\"source\":56,\"target\":54,\"weight\":13},{\"source\":56,\"target\":55,\"weight\":7},{\"source\":56,\"target\":51,\"weight\":6},{\"source\":74,\"target\":89,\"weight\":7},{\"source\":74,\"target\":49,\"weight\":5},{\"source\":21,\"target\":75,\"weight\":9},{\"source\":21,\"target\":90,\"weight\":5},{\"source\":31,\"target\":40,\"weight\":4},{\"source\":26,\"target\":28,\"weight\":4},{\"source\":37,\"target\":12,\"weight\":4},{\"source\":37,\"target\":35,\"weight\":6},{\"source\":37,\"target\":91,\"weight\":10},{\"source\":37,\"target\":38,\"weight\":29},{\"source\":37,\"target\":92,\"weight\":9},{\"source\":37,\"target\":4,\"weight\":5},{\"source\":37,\"target\":5,\"weight\":4},{\"source\":6,\"target\":67,\"weight\":11},{\"source\":6,\"target\":78,\"weight\":8},{\"source\":6,\"target\":80,\"weight\":7},{\"source\":6,\"target\":84,\"weight\":10},{\"source\":6,\"target\":85,\"weight\":9},{\"source\":6,\"target\":86,\"weight\":7},{\"source\":6,\"target\":87,\"weight\":8},{\"source\":6,\"target\":88,\"weight\":12},{\"source\":27,\"target\":1,\"weight\":7},{\"source\":82,\"target\":93,\"weight\":30},{\"source\":82,\"target\":1,\"weight\":5},{\"source\":46,\"target\":45,\"weight\":5},{\"source\":58,\"target\":52,\"weight\":4},{\"source\":76,\"target\":71,\"weight\":5},{\"source\":76,\"target\":4,\"weight\":4},{\"source\":7,\"target\":94,\"weight\":6},{\"source\":7,\"target\":95,\"weight\":6},{\"source\":30,\"target\":75,\"weight\":4},{\"source\":85,\"target\":84,\"weight\":6},{\"source\":70,\"target\":21,\"weight\":8},{\"source\":70,\"target\":75,\"weight\":7},{\"source\":70,\"target\":49,\"weight\":4},{\"source\":60,\"target\":22,\"weight\":5},{\"source\":60,\"target\":44,\"weight\":7},{\"source\":60,\"target\":56,\"weight\":5},{\"source\":60,\"target\":3,\"weight\":6},{\"source\":97,\"target\":11,\"weight\":4},{\"source\":17,\"target\":29,\"weight\":8},{\"source\":39,\"target\":65,\"weight\":15},{\"source\":39,\"target\":68,\"weight\":6},{\"source\":39,\"target\":10,\"weight\":23},{\"source\":39,\"target\":33,\"weight\":6},{\"source\":39,\"target\":11,\"weight\":17},{\"source\":39,\"target\":34,\"weight\":32},{\"source\":39,\"target\":24,\"weight\":5},{\"source\":39,\"target\":2,\"weight\":15},{\"source\":39,\"target\":36,\"weight\":18},{\"source\":39,\"target\":15,\"weight\":10},{\"source\":39,\"target\":16,\"weight\":14},{\"source\":39,\"target\":31,\"weight\":10},{\"source\":39,\"target\":38,\"weight\":5},{\"source\":39,\"target\":96,\"weight\":4},{\"source\":39,\"target\":97,\"weight\":7},{\"source\":39,\"target\":17,\"weight\":15},{\"source\":39,\"target\":18,\"weight\":4},{\"source\":39,\"target\":41,\"weight\":15},{\"source\":39,\"target\":42,\"weight\":4},{\"source\":39,\"target\":29,\"weight\":11},{\"source\":39,\"target\":4,\"weight\":12},{\"source\":39,\"target\":5,\"weight\":12},{\"source\":39,\"target\":32,\"weight\":26},{\"source\":3,\"target\":77,\"weight\":4},{\"source\":3,\"target\":22,\"weight\":5},{\"source\":3,\"target\":70,\"weight\":4},{\"source\":3,\"target\":42,\"weight\":5},{\"source\":3,\"target\":20,\"weight\":4},{\"source\":92,\"target\":91,\"weight\":4},{\"source\":18,\"target\":33,\"weight\":4},{\"source\":1,\"target\":73,\"weight\":6},{\"source\":1,\"target\":67,\"weight\":34},{\"source\":1,\"target\":79,\"weight\":12},{\"source\":1,\"target\":80,\"weight\":36},{\"source\":1,\"target\":0,\"weight\":43},{\"source\":1,\"target\":81,\"weight\":6},{\"source\":1,\"target\":6,\"weight\":10},{\"source\":1,\"target\":84,\"weight\":5},{\"source\":19,\"target\":9,\"weight\":15},{\"source\":19,\"target\":13,\"weight\":5},{\"source\":19,\"target\":45,\"weight\":4},{\"source\":19,\"target\":46,\"weight\":4},{\"source\":19,\"target\":3,\"weight\":6},{\"source\":19,\"target\":20,\"weight\":10},{\"source\":41,\"target\":65,\"weight\":22},{\"source\":41,\"target\":10,\"weight\":10},{\"source\":41,\"target\":33,\"weight\":5},{\"source\":41,\"target\":12,\"weight\":16},{\"source\":41,\"target\":2,\"weight\":10},{\"source\":41,\"target\":15,\"weight\":35},{\"source\":41,\"target\":16,\"weight\":4},{\"source\":41,\"target\":74,\"weight\":5},{\"source\":41,\"target\":21,\"weight\":14},{\"source\":41,\"target\":37,\"weight\":28},{\"source\":41,\"target\":75,\"weight\":36},{\"source\":41,\"target\":91,\"weight\":9},{\"source\":41,\"target\":76,\"weight\":4},{\"source\":41,\"target\":90,\"weight\":7},{\"source\":41,\"target\":38,\"weight\":28},{\"source\":41,\"target\":30,\"weight\":8},{\"source\":41,\"target\":70,\"weight\":4},{\"source\":41,\"target\":17,\"weight\":7},{\"source\":41,\"target\":3,\"weight\":5},{\"source\":41,\"target\":92,\"weight\":6},{\"source\":41,\"target\":19,\"weight\":6},{\"source\":41,\"target\":48,\"weight\":8},{\"source\":41,\"target\":4,\"weight\":77},{\"source\":48,\"target\":98,\"weight\":4},{\"source\":48,\"target\":49,\"weight\":8},{\"source\":105,\"target\":93,\"weight\":5},{\"source\":42,\"target\":77,\"weight\":4},{\"source\":42,\"target\":68,\"weight\":4},{\"source\":42,\"target\":93,\"weight\":32},{\"source\":42,\"target\":82,\"weight\":20},{\"source\":42,\"target\":70,\"weight\":15},{\"source\":42,\"target\":1,\"weight\":13},{\"source\":71,\"target\":75,\"weight\":5},{\"source\":4,\"target\":68,\"weight\":4},{\"source\":4,\"target\":43,\"weight\":31},{\"source\":4,\"target\":98,\"weight\":5},{\"source\":4,\"target\":99,\"weight\":5},{\"source\":4,\"target\":44,\"weight\":5},{\"source\":4,\"target\":94,\"weight\":4},{\"source\":4,\"target\":14,\"weight\":22},{\"source\":4,\"target\":45,\"weight\":5},{\"source\":4,\"target\":81,\"weight\":5},{\"source\":4,\"target\":74,\"weight\":11},{\"source\":4,\"target\":21,\"weight\":6},{\"source\":4,\"target\":95,\"weight\":9},{\"source\":4,\"target\":75,\"weight\":7},{\"source\":4,\"target\":46,\"weight\":5},{\"source\":4,\"target\":7,\"weight\":25},{\"source\":4,\"target\":38,\"weight\":12},{\"source\":4,\"target\":30,\"weight\":28},{\"source\":4,\"target\":47,\"weight\":11},{\"source\":4,\"target\":70,\"weight\":6},{\"source\":4,\"target\":3,\"weight\":9},{\"source\":4,\"target\":19,\"weight\":4},{\"source\":4,\"target\":48,\"weight\":21},{\"source\":4,\"target\":42,\"weight\":6},{\"source\":4,\"target\":49,\"weight\":18},{\"source\":5,\"target\":68,\"weight\":5},{\"source\":5,\"target\":11,\"weight\":4},{\"source\":5,\"target\":12,\"weight\":16},{\"source\":5,\"target\":14,\"weight\":7},{\"source\":5,\"target\":2,\"weight\":13},{\"source\":5,\"target\":15,\"weight\":13},{\"source\":5,\"target\":74,\"weight\":14},{\"source\":5,\"target\":95,\"weight\":5},{\"source\":5,\"target\":7,\"weight\":6},{\"source\":5,\"target\":38,\"weight\":4},{\"source\":5,\"target\":30,\"weight\":5},{\"source\":5,\"target\":47,\"weight\":5},{\"source\":5,\"target\":3,\"weight\":11},{\"source\":5,\"target\":42,\"weight\":15},{\"source\":5,\"target\":71,\"weight\":4},{\"source\":5,\"target\":4,\"weight\":39},{\"source\":5,\"target\":87,\"weight\":4},{\"source\":5,\"target\":49,\"weight\":6},{\"source\":5,\"target\":32,\"weight\":4},{\"source\":87,\"target\":78,\"weight\":7},{\"source\":49,\"target\":47,\"weight\":4},{\"source\":61,\"target\":60,\"weight\":7},{\"source\":61,\"target\":4,\"weight\":4},{\"source\":32,\"target\":31,\"weight\":12},{\"source\":32,\"target\":38,\"weight\":6},{\"source\":32,\"target\":40,\"weight\":6},{\"source\":106,\"target\":2,\"weight\":10},{\"source\":88,\"target\":84,\"weight\":7},{\"source\":88,\"target\":85,\"weight\":9}]}","link":"/test_files/got_social_graph.json"}],"posts":[{"title":"英语学习总结（英标篇）--- 比较难发对的音（持续更新...大概）","text":"主要目标 A E I O U 五个 vowel sound 的 long 和 short 发音规则和区别，特别要注意 short i 的发音规则L 发音要注意的问题，注意 L 在单词不同位置的发音区别B &amp; P 发音的发音区别Th 发音练习V 发音练习 A E I O U 发音练习 Word A E I O U Long late [leɪt] Feet [fiːt] Fight [faɪt] Phone [fon] Cute [kjuːt] Short Bat [bæt] Bet [bet] bit [bɪt] bot [bɑt] but [bʌt] 要特别注意 Short i 的发音规律 Silent ‘E’ Rule (轻声 E 规则)，如果一个单词最后一个字母是 E 一般是 Long I(长 I 音)，Eg： Kite，Fine，Ride，Five，但也有特例：give 和 live； Y 这个字母一般是 Long I 的声音，By, My, Sky, July, 但也有特例，Gym，Symbol, System U 这个词偶尔会用作short I， Busy，Building 长元音，短元音如果发音不准可能会造成误会的单词： Long VS Short: 12345678910ship[ʃɪp] vs sheep[ʃip]fit[fɪt] vs feet[fit]sit[sɪt] vs seat[sit]chip[tʃɪp] vs cheap[tʃip]List [lɪst] vs least[list]His[hɪz] vs he’s[hi:z, 弱 hiz, iz]It[ɪt] vs eat[it]Hit[hɪt] vs heat[hit]slip[slɪp] vs sleep[slip]Live[laɪv；lɪv] vs leave [liv] 关于 Short I 绕口令（Tongue Twister）：12345678910Long I:My kite flew hight in the sky.The ice cream last night was fine.The final drive was a nice ride.Short I:Let's sit on the big thick Brick.The six pigs stink.A Kitten sitting in a kitchen. 发音技巧 tips:1234 It’s a very short i sound. It should only last a second or less.Short i: Tongue, central high, mouth slightly open把舌头放在嘴中稍微开口，不要把舌头触碰到后面的牙齿Long I: long time, mouth wide open Short i 发音图 ![Short i](http://pib8sx71d.bkt.clouddn.com/Short%20i%20sound.png) L 音L 音可以是 Light L (一般在一个单词的前面)，比如：Love， like， life，还可以是 Dark L（一般在单词的后面），比如：apple，feel，special，real, health, style, tall, girl Dark L 发音图： ![Dark L down-w500](http://pib8sx71d.bkt.clouddn.com/Dark%20L%20%E5%8F%91%E9%9F%B3%E5%9B%BE.png) Dark L & Light L 绕口令练习 （Tongue Twister）： Light L: I like to learn languages.Lisa loves Lary a lot.This is a long Blog about Learning. Dark L: It is a really good deal.he small ball fell in the cool pool.The small ball fell in the cool pool.call the tall girl. Light L &amp; Dark L: please leave the whole glass of milk on the table.look at the really little flag.I will list all of the final details in my letter.Please send the last email to my family. Th ð 音（Voiced Sound）VS Th θ 音（Unvoiced sound）Th 发音图： ![Dark L down-w500](http://pib8sx71d.bkt.clouddn.com/th%20%E5%8F%91%E9%9F%B3.png) Th ð 音常见的单词有： This， That， Those， Other 相对应的绕口令练习 （Tongue Twister）： Father, Mother, sister, brother, together they love each other. They clothed themselves, then they breathed their last breath. The leather feather was smoother than the other. Southern weather together with northern weather. Th θ 音（Unvoiced sound），首先 TH $\\neq$ S 发音不对可能造成的误解，比如： Think VS SinkThing VS SingFaith VS Face Th 绕口令练习 （Tongue Twister）： Thelma and Theo have bad breath. I’ll bring three thousand things with me on Thusday Thor thought it was north thankfully it was south. Three thousand thistles through the thick of his thumb. 针对 Th ð 音 和 Th θ 音以后还需注意的问题：比如单词相似发音区别很大的音 Breathe VS BreathBath VS BathClothe VS Cloth B &amp; P （Voiced VS Unvoiced）发音tips: 12首先 Voiced 和 Unvoiced 区别在于手放到脖子上是否震动的感觉，而Unvoiced 气息是从口中直接蹦出来的（说的可能不太好，自己可以接着查阅相关的资料） Voiced： Big， Boy， By，Th ð 音Unvoiced：Pig， Pay，Pie，Th θ 音 Voiced Big Buy Bear Bet Bill Cub Bland Bride Pub Robe Cab Unvoiced Pig Pie Pear Pet Pill Cup Planned Pride Pup Rope Cap Th ð 绕口令练习 （Tongue Twister）： Petter Piper Picked a peck of pickled peppers. Betty Botter brought a bit of bitter butter. Please put the bread and butter back on top of the table. Bob poured pop on the puppy before he brought a big pie. Happy Birthday! V 发音有个简单的绕口令和 W 音进行区分，：Kiss your W’s(么么哒的姿势)，Bite your V’s（上齿能碰到下嘴唇，下唇和下齿相平行） V 音 Very Vine Vent Vest Verse Vin W 音 Wary Wine Whale West Worse Win tips: 1V 音不管在单词哪个位置（前中后）的发音都是一样 V 发音 绕口令练习 （Tongue Twister）： I have five knives. My family loves to laugh on vacation. Victor’s friend Vincent has five vests in vinegar. Vivian is very wary of Vinnie and Winnie. We went to Wally’s volleyball event with victory in mind. Wally would win the volley versus Vinnie. The four wolves live in the cave. Wild vines make fine flavor for wines. V 发音图： ![Dark L down-w300](http://pib8sx71d.bkt.clouddn.com/V%20%E5%8F%91%E9%9F%B3.png)","link":"/2019/11/25/%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E8%8B%B1%E6%A0%87%E7%AF%87)/"},{"title":"北京大学暑期学校-数据可视化学校(更新中...)","text":"","link":"/2022/07/08/%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87/%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E6%A0%A1-%E6%9B%B4%E6%96%B0%E4%B8%AD/"},{"title":"深度学习浅显理解","text":"基于深度学习卷积神经网络分析道路破损情况1.1 研究背景&nbsp;&nbsp;&nbsp;&nbsp;道路的建设不仅促进了地域之间的交流，也使得地域之间的经济交流更加密切，更好的促进了社会和经济的发展，但道路建设到了后期会面临着很多问题，比如路面保养，路面修缮，路面特殊情况的处理。如果这些问题不能及早的发现，不仅对车和行人安全造成巨大的隐患，还会缩短路面的使用期限，缩短路面的寿命。若能及时发现和排查问题所在，防患未然，能极大的缩小道路修缮的维护成本。&nbsp;&nbsp;&nbsp;&nbsp;当前，路面检测主要是靠两种途径来完成的，一种是人工实地勘测，另一种是使用影像检查路面情况。&nbsp;&nbsp;&nbsp;&nbsp;人工实地勘测工作量大，效率低，检查中会影响车辆以及行人，也会造成一些安全上的隐患，并且人工检检查会有主观倾向性，和实际测量结果之间可能有很大的误差。&nbsp;&nbsp;&nbsp;&nbsp;后来使用影像技术来监测路面破损程，即对路表面拍摄高清晰照片，通过图像处理获取路面裂缝，泛油与修补等信息。该方法能极大的提高路面检测的效率和精度，同时大大的降低劳动成本。&nbsp;&nbsp;&nbsp;&nbsp;随着技术的发展基于人脑神经元网络抽象的人工神经网络（Artificial Neural Networks,ANNs）自20世纪80年代以来，成为图像处理和人工智能领域研究的新兴热点。深度学习（DeepLearning，DL）的起源来自于 ANNs，宏观的可以认为 DL 属于 ANNs 中含有多隐层感知器的一种特殊网络结构。而深度学习技术在图像处理领域的迅速发展，深深的影响了在路面图像破损目标识别方面的研究进展，也为我们提供了一个很很好的解决问题的方式1.2 传统路面裂缝检测算法国内外研究进展1.2.1 路面裂缝图像预处理算法&nbsp;&nbsp;&nbsp;&nbsp;在图像识别技术中，由于路面裂缝图像的采集来源于人工干预方式，因此得到的路面裂缝数据集质量会受到诸如光照强度、雨雾天气、路面油渍等各种外界因素的影响，而路面裂缝图像质量的好坏直接影响着图像识别算法的设计及识别效果精度。要想提高图像识别算法各方面的性能，除了在原始算法基础上进行优化以外，图像预处理技术在整个图像处理技术中占有非常重要的地位。根据对目前已有预处理算法的研究，可以将比较广发使用的图像预处理方法分为两大类：图像背景差法和图像细节增强法。&nbsp;&nbsp;&nbsp;&nbsp;图像背景差法是指将当前所获得原始图像与经过处理的背景图像进行求灰度差运算，得到目标区域灰度图的一种方法。Cheng 等[1/6]提出了一种基于模糊逻辑的路面裂缝检测算法，该算法的主要思想基于路面图像中裂缝处的灰度值比周围的背景图像灰度值低，且裂缝处的像素比背景环境的像素更为连续的事实。该方法首先通过确定差分图像灰度的亮度隶属函数来确定裂缝处像素比周围背景的灰度值暗多少，其次求出路面图像中裂缝像素的灰度域值范围，最后检查较暗像素区域的连通性来消除伪裂缝的存在。研究表明，该方法可以有效的检测到包含大量噪音的路面图像中存在的薄弱裂缝。&nbsp;&nbsp;&nbsp;&nbsp;细节增强法是根据裂缝与背景图像在路面图像中体现出的频域不同，裂缝目标表现出高频特征，而噪音表现出的是低频特征，对路面图像中的高频特征进行增强，以此来加强路面图像中裂缝与背景部分的对比度，进而进行裂缝目标识别。Zou 等[2/7]将小波包引入到路面图像预处理环节的降噪过程中，该算法将路面图像分解后，在路面图像的每一级尺度上按照不同的参数进行降噪处理，最后对路面图像进行重建。在以实际路面图像为数据的基础上进行实验，结果表明该方法表现出其高效性，并且可以有效的处理路面图像的噪音。然而，随着输入的路面裂缝图像的多样性，应用系统很难自适应地调整非线性函数的参数。&nbsp;&nbsp;&nbsp;&nbsp;对比背景差法和细节增强法可见：在处理范围方面，前者偏向于路面裂缝图像的宏观处理方向，后者着重于路面裂缝图像的微观处理方向；数据处理量方面，前者数据计算量明显低于后者数据计算量；在适应性方面，前者不仅可以处理高频信息，还可以很好的处理低频噪音等信息，因此普适性高于后者。&nbsp;&nbsp;&nbsp;&nbsp;两种方法的缺点：背景差法容易漏掉对路面裂缝细节信息的处理，细节增强法则因其繁杂的数据计算量而致使其适应性不好。1.2.2 路面裂缝图像分类算法&nbsp;&nbsp;&nbsp;&nbsp;裂缝在路面破损图像中，表现出诸如龟裂、多纹理性、多方向性等多样性。相关领域专家分别对不同特征的路面裂缝图像进行单独研究[3/8]，现在已经存在的路面裂缝分类算法有很多种。对目前普遍使用的路面裂缝分类算法，大体可以划分为下面这八类：基于阈值的路面图像分割法、基于边缘检测的识别方法、基于多尺度[4/12]检测的裂缝识别方法、基于裂缝纹理的检测法、基于多特征融合的路面裂缝检测方法、基于图论的裂缝检测方法、基于深度学习的路面裂缝识别方法、以及其他分类方法。&nbsp;&nbsp;&nbsp;&nbsp;其中基于阈值的路面图像分割法中有一个是老师(TANAKA Naoki)等人早年间的研究，利用数学形态学的几种算子对路面裂缝进行检测，其适用于模糊的裂纹，但对于微小裂缝而言，该方法不太适应用[5//10]。还有就是 Xu[6/14] 提出将路面裂缝图像统一划分为8x8像素大小的网格图像，基于含有网格的路面图像检测其网格边界是否包含“波谷”来断定图像中裂缝的存在可能，该方法称为 GCA 的边缘检测算法。判别裂缝的方式如下，如果网格图像中存在“波谷”，那么将边界上像素中灰度最小值设置为种子点，然后校验和跟踪这些种子点即可。该方法是在多次不同情况下进行驾驶检测的，识别结果发现在反复多次的检测中具有良好的准确性。&nbsp;&nbsp;&nbsp;&nbsp;尽管目前路面裂缝识别算法已经相当成熟，但是仍然存在各种各样的条件限制着路面裂缝识别的准确率及实时效果[7/18]。1.3 目前存在的主要问题&nbsp;&nbsp;&nbsp;&nbsp;现如今的图像采集设备及技术一直在稳步前进，但是采集到的路面图像依旧会受采集设备的拍摄角度、光照、遮挡等外界因素的影响，通常获取的路面图像都会出现灰度不均匀[8/26]。传统的裂缝识别算法，在对这些路面裂缝图像进行分类识别前，均需先进行路面图像的去模糊、去除噪声、增强对比度等预处理工作，以减少后期处理中较大数据处理量及较高误识别率。&nbsp;&nbsp;&nbsp;&nbsp;综上，在路面裂缝图像分类识别过程中，目前主要存在以下几类问题：&nbsp;&nbsp;&nbsp;&nbsp;采集不到无噪音影响的纯净路面裂缝图像数据[8/27]，反而想要得到这样的数据，需要非常昂贵的成本；&nbsp;&nbsp;&nbsp;&nbsp;传统路面裂缝图像的预处理、特征提取、分类器训练以及最终的分类，均需要拥有多年图像处理工作的专业工程师进行人工辅助，这些过程均以经验为驱动，未能实现自动处理；&nbsp;&nbsp;&nbsp;&nbsp;传统的路面裂缝图像分类技术通用性较差，致使最终的分类精度到了瓶颈期，上升空间较小。1.4 深度学习神经网络相关介绍&nbsp;&nbsp;&nbsp;&nbsp;深度神经网络的构思来源于生物神经系统，因此深度神经网络模型亦是以神经元为基础的。同时深度神经网络具有并行分布处理图像数据的特点、网络模型兼备高鲁棒性及高容错能力、并且分布式存储数据及高度学习能力、能够充分逼近复杂的非线性关系等优点，让深度神经网络在极短的时间内凸显出其超群的优越性。1.4.1 单隐层神经网络&nbsp;&nbsp;&nbsp;&nbsp;基于神经元多输入单输出的特性，通过重构网络拓扑、节点特点及学习规则来对神经网络进行建模。一个常见的简单神经元数学模型，如下图 1.1 所示。&nbsp;&nbsp;&nbsp;&nbsp;单隐层神经网络模型相当于是对神经元数学模型进行一个宏观的包装，模型主要包括三层，即：输入层、隐层和输出层。单隐层神经网络与神经元模型不同的是，神经元模型是单输出，而单隐层神经网络模型是多输出，其网络结构如图 1.2 所示。1.4.2 多隐层神经网络&nbsp;&nbsp;&nbsp;&nbsp;对单隐层神经网络进行延伸可知，当隐层个数超过2 层（包括2 层）时，我们就将这类网络定义为多隐层神经网络。多隐层神经网络是一种包含多个隐层、全连接层的有向无环的网络结构。值得注意的是这类网络只有输入层、隐层和输出层。如下图 1.3 所示为简单的多隐层神经网络结构图：1.4.3 深度学习网络&nbsp;&nbsp;&nbsp;&nbsp;深度学习是目前机器学习领域比较热门的一项技术。从网络的结构来说，我们可以认为深度学习网络是多隐层神经网络的一种特殊形式，该技术可以打破传统神经网络的瓶颈，建立更类似于生物神经网络分析处理诸如声音、文本、图像等数据的数学模型。深度学习的网络范式包括数据、模型、优化和求解四步，基于人工神经网络，深度学习网络加入了更多的层，如卷积层、池化层、Dropout 层等。&nbsp;&nbsp;&nbsp;&nbsp;相对于多层神经网络模型的以下几个常见的不足：1、人工提取原始数据特征的方式，在面对大数据时，过滤数据量，需要耗费大量的时间，并且对特征尺度的提取比较难把握，训练出来的模型对噪音敏感度较高；2、更高的精确度意味着更深的网络层次，而随着网络层的不断加深，网络难免出现梯度扩散问题；3、多层神经网络里面没有设置处理时间序列的参数，网络不能处理跟时间相关的数据；深度学习网络的下面几个特点，刚好弥补了多层神经网路的不足：1、深度学习网络自动提取输入数据的特征，无需人工参与，且网络自动获取的数据特征更能体现实物的特征，可以获得泛化能力更强的网络模型；2、根据不同的应用，可以将深度学习网络模型调整为适用于该应用的网络架构；3、深度学习网络加入了反馈和时间参数，使网络的应用范围更广。1.5 卷积神经网络介绍&nbsp;&nbsp;&nbsp;&nbsp;卷积神经网络是由多层感知器经过变化而得。由生物学家Hubel 和Wiesel 在早期关于猫视觉皮层的研究发展而来。视觉皮层的细胞是一个构造十分复杂的结构。这些细胞对视觉输入空间的子区域非常敏感,称之为感受野,以这种方式平铺覆盖到整个视野区域。这些细胞的基本类型有两种,简单细胞作为一种其作用是响应来自感受野范围内的边缘刺激模式。不同于简单细胞，复杂细胞的接收域范围更大,而且它具有局部不变性。卷积神经网络是非全连接的多层神经网络，每层的组成是多个二维平面，多个独立的神经元组成了对应的二维平面，正如卷积神经网络模型如图 1.4 所示，它包含了卷积层和亚采样层两个网络结构。检测不同特征的不同滤波器在输入文件上被卷积，并且输出一组激活图，其被传递到CNN中的下一层[9/斯坦福大学]。公式用于确定激活图的维度：$（N + 2P-F）/ S + 1$; 其中$N =图像（输入）$文件的尺寸&nbsp;&nbsp;$P =填充$&nbsp;&nbsp;$F =滤波器的尺寸$&nbsp;&nbsp;$S = Stride$1.5.1 激活功能激活功能是放置在神经网络末端或之间的节点。它们有助于确定神经元是否会发射。有不同类型的激活函数，如图 1.8 所示，这里重点讲一下整流线性单元（ReLU）。ReLU函数是当今神经网络中使用最广泛的激活函数。ReLU 相对于其他激活功能的最大优势之一是它不会同时激活所有神经元。从上面的 ReLU 函数图像中，我们会注意到它将所有负输入转换为零，并且神经元不会被激活。这使得它非常有计算效率，因为每次激活的神经元很少。它不会在正区域饱和。在实践中，ReLU 的收敛速度比 tanh 和 S 形激活函数快6倍。ReLU提出的一些缺点是它在负区域饱和，这意味着该区域的梯度为零。在梯度等于零的情况下，在反向传播期间，所有权重都不会更新，为了解决这个问题，我们使用Leaky ReLU。此外，ReLU功能不是以零为中心的。这意味着为了使其达到最佳点，它必须使用可能更长的锯齿形路径。1.5.2 池层可以在 CNN 架构中的卷积层之间看到池化层。该层基本上减少了网络中的参数和计算量，通过逐渐减小网络的空间大小来控制过度拟合。该层有两个操作; 平均合并和最大合并。这里只讨论 Max-pooling。1.5.3 最大池就像名字所说; 只会从游泳池中取出最大值。这实际上是通过使用滑过输入的滤波器完成的; 并且在每一步都取出最大参数，其余参数被删除。这实际上是对网络进行下采样。与卷积层不同，池化层不会改变网络的深度，深度维度保持不变。Max-pooling后输出的公式：$（N - F）/ S + 1 $; 其中 $N =汇集层的输入维度$$F =滤波器的尺寸$$S = Stride$1.5.4 完全连接的层在该层中，神经元与先前层的所有激活完全连接。因此，可以通过矩阵乘法后跟偏置偏移来计算它们的激活。这是CNN网络的最后阶段。卷积神经网络实际上由隐藏层和完全连接的层组成。卷积神经网络训练过程卷积神经网络可以学习大量的输入到输出之间的映射关系，即其本质就是一种从输入端到输出端的映射，在学习的过程中不需要输入与输出之间存在任何的可以用表达式表示出的关系，只要用已知的数据对网络加以训练，网络最终就能够具有输入到输出之间的映射能力。卷积神经网络的训练原理是根据链式求导计算损失函数对每个权重的偏导数，然后根据梯度下降公式对权重进行更新。采用的是反向传播算法。主要包括四个步骤：前向传播阶段：（1）从样本集中取出一个样本(M, N )，将 M 输入网络；（2）计算对应的实际输出值O；1.6 路面裂缝图像预处理及识别方法1.6.1 路面裂缝类别&nbsp;&nbsp;&nbsp;&nbsp;公路路面在长时间的自然条件作用，以及车辆的行驶速度、紧急刹车、车辆载重等影响下，公路路面会出现不同种类、不同程度的破损，在影响道路服务的能力同时还会影响到车辆的安全，所以需要进行道路维护。由于裂缝类型相异，所以针对不同类别的路面破损情况应采取不同的维护方法，这样不仅有利于维护的效率，而且还能节约维护成本，节约资源。所以能够准确的对路面破损的类别、破损的程度进行分类识别和评定，对路面维护和提高服务能力具有重要意义。以下是一些常见的裂痕种类：&nbsp;&nbsp;&nbsp;&nbsp;横向裂缝，横向裂缝是指与路面中心线垂直的裂缝，裂缝有的贯穿部分路面，有的贯穿整个路面，长短不一且呈现弯曲状，有深有浅并伴有少量的细小分支，如图 3.1 所示。横向裂缝的成因主要是由温度变化导致的路基和路表不均匀缩涨和路基差异性沉陷，同时在积水的作用下对路面裂缝造成冲刷致使裂缝深度加深，导致分离加重，再由路面设计不合理、施工质量低劣或车辆超载等因素的影响导致混凝土伸缩和沥青分离出现裂缝变形。&nbsp;&nbsp;&nbsp;&nbsp;纵向裂缝，纵向裂缝是指与行车方向基本平行的裂缝，其裂缝的走向较为单一且长度和宽度不一，并且形状带有弯曲，只有少量的纵向裂缝带有小分支。纵向裂缝一般由于在施工过程中路基压实度不够、不均匀、土块粉碎不充分所引起的，多出现在路肩和行车道部位，随着积水的冲刷以及车辆超载极易引起裂缝宽度的增加，危害行车安全，增加维护成本。&nbsp;&nbsp;&nbsp;&nbsp;网状裂缝，网状裂缝也叫龟裂，在载荷重复作用的情况下导致基层被软化，形成大量横向和纵向裂缝相互交错在一起的密集小块，呈现网格状，如图 3.3 所示。网状裂缝的缝宽在 1mm 以上，两条裂缝的距离在40cm 以下，其区域边缘构成的总面积在 1m2 以上的网格状裂缝。造成网状裂缝的产生主要原因有路基不实、微小裂痕经过长时间碾压、重复载荷等。网状裂缝如果不及时处理，在温度变化较大、雨水冲刷、车辆超重等情况下极易形成大面积的破坏。&nbsp;&nbsp;&nbsp;&nbsp;块状裂缝，块状裂缝是由不规则少量的网状裂痕形成的，如图 4.4 所示。块状裂缝其横纵裂缝较为稀疏，裂缝块的大小一般在9m2 之内。大多都是由于路面老化、久经风雨造成的。1.6.2 路面裂缝破损程度评定&nbsp;&nbsp;&nbsp;&nbsp;不同环境的路面均会出现不同类型、不同破损程度及范围的裂缝，为了更加准确具体的掌握路面破损的情况，可以及时对破损路面进行修复，所以对路面破损程度的严重性以及综合因素考虑变得十分重要。所以为了便于比较和分类，通常使用 Pavement Condition Index（PCI）作为路面破损状况的评价标准[34]。路面状况指数 PCI 的取值范围为 1 到 100，越接近 100 表示路面状况良好，根据 PCI 数值的大小，可将路面状况分为 5 个等级，对于较优的路面状况，就可以排除在需要修复范围之外，而对破损程度不一的状况则需要进行不同程度的修复。&nbsp;&nbsp;&nbsp;&nbsp;路面状况指数 PCI 的计算公式为：$$PCI = 100 - DR^{0.412}$$&nbsp;&nbsp;&nbsp;&nbsp;其中 DR 为综合破损率，是沥青路面破损调查指标，其计算公式为：$$DR = D/A = D_{ij}K_{ij}/A$$&nbsp;&nbsp;&nbsp;&nbsp;其中 D 表示评价路段内的折合破损面积；A 表示评价路段的路面总面积；$D_{ij}$ 表示第 i 类破损、第 j 种破损程度的实际破损面积；$K_{ij}$ 为第 i 类破损、第 j 种破损程度的换算系数；i，j 分别表示破损类型和破损程度。 #### 路面破损换算系数（K） 破损类型 外观描述 破损程度 换算系数 横向裂缝 轻：少分支、缝隙小、缝壁无散落；中：少分支、缝隙较小、缝壁散落轻微；重：少分支、缝隙较大 轻/中/重 0.6/0.8/1.0 纵向裂缝 轻：少分支、缝隙小、缝壁无散落；重：少分支多、缝隙较大、缝壁散落严重 轻/重 0.2/ 0.4 网状裂缝 轻：缝细、缝壁无散落、变形不明显；重：网格众多、缝壁散落严重、缝隙较大 轻/重 0.4/0.6 块状裂缝 轻：缝细、缝壁无散落、块状大；重：缝宽、缝壁散落严重、块状小 轻/重 0.2/0.4 1.7 路面破损图像预处理&nbsp;&nbsp;&nbsp;&nbsp;由于公路路面状况较为复杂，且受到环境、路面清洁情况、图像采集角度、光照强度以及光照均匀程度的影响，使得图像采集准确度十分困难，并对以后的特征提取带来诸多困难。为了提高图像质量，需要消除采集过程中的不利影响，使得特征更加精确明显，更好的表达裂缝的破损程度及类型等信息，所以需要对目标图像进行预处理，不仅有利于训练处理，还可以提高训练效果和识别精度。在路面图像预处理过程中，常用的方法有：灰度变换、直方图均衡化、中值滤波、形态学处理等，接下来对四种方法分别进行简要介绍。1.7.1 灰度变换&nbsp;&nbsp;&nbsp;&nbsp;图像灰度变换是为了改善画质，使目标图像显示的效果更加清晰，可以有选择性的突出目标图像中的特征区域，并抑制图像中的干扰因素（噪声）。其主要原理是通过再次计算数据图像中灰度值的范围，使得原始图像的像素值得到重新分配，从而增强图像的对比度。灰度变换常用的方法有：图像求反、对数变换、灰度切割、位图切割、灰度的线性变换。本文使用灰度得线性变换方法对路面裂缝图像进行处理。记原始图像的灰度为 $f(x, y)$，经过变换后的数据图像灰度记为 $g(x, y)$，灰度变换的计算式如下：$$g(x,y)=\\frac{Y_{b}-Y_{a}}{X_{b}-X_{a}}\\left[f(x,y) - X_{a}\\right] + Y_{a}$$ 其中，$X_{a}$ 表示原始图像灰度的最小值，$X_{b}$ 表示最大值；$Y_{a}$ 表示经过变换后的图像灰度值的最小值，$Y_{b}$ 表示最大值，即 $\\frac{Y_{b}-Y_{a}}{X_{b}-X_{a}}$ 表示线性斜率。斜率大于 1 时，输出的图像对比度增加，小于 1 时对比度减小，等于 1 时图像灰度值上移或下移，小于 0 就会使暗区域变亮，亮区域变暗。通过灰度变换图像的灰度值范围由$（X_{a}, X_{b}）$ 变为 $（Y_{a}, Y_{b}）$。1.7.2 灰度变换####&nbsp;&nbsp;&nbsp;&nbsp;直方图均衡化利用图像直方图对对比度进行调整，在路面裂缝图像中，路面背景与裂缝的对比度相对较为接近。直方图均衡化对图像进行非线性拉伸，重新分配图像像素值，而把给定的直方图分布变成均匀分布的直方图。在相对信息量较大的图像中，通过将图像的对比度增强达到数据图像清晰度增加的目的。该方法较为直观，而且操作具有可逆性，可以恢复原始的直方图。 1.7.3 中值滤波####&nbsp;&nbsp;&nbsp;&nbsp;中值滤波对噪声有良好的滤除作用，能够有效的保护信号的边缘。在路面裂缝图像采集过程中，由于各种各样噪声的影响不仅不利于影响了训练速度的提升也严重干扰了图像的特征提取。中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理方法，能够很好地抑制图像中的噪声。 &nbsp;&nbsp;&nbsp;&nbsp;中值滤波通过把数字图像中的一个点值通过用该点领域中各个点值的中值来代替，使得它周围的像素值更加接近真实值，从而使孤立的噪声点被消除掉。因为噪声的存在，使得该点的像素会比周围的像素亮或者暗许多，所以通过对像素由小到大重新排列之后，亮的点或者暗的点就会被排到两侧，并取中间位置的像素灰度值来替代待处理像素的值，从而到达消除噪声的目的。1.7.4 形态学图像处理####&nbsp;&nbsp;&nbsp;&nbsp;形态学图像处理方法可以有效的解决形状识别、抑制噪声、纹理分析、边缘检测、图像压缩等问题，主要以几何结构为基础，且提取的边缘较为光滑，断点少，可以有效的保持原始图像，而能否有效的提取信息的关键在于结构元的选择，结构元的选择必须比原图像要简单并且有边界。路面裂缝图像经过灰度变换、直方图均衡化和中值滤波处理后仍然会存在孤立的噪声点或者细小的裂缝，为了减弱噪声点和细小裂缝对路面图像特征提取的影响需要使用形态学处理方法消除这些噪声点和连接细小裂缝。 参考文献 :[1] MOHAN A, POOBAL S. Crack detection using image processing: a critical review and analysis[J]. Alexandria Engineering Journal [2] JIANG Ming-hu, GIELEN G, DENG Bei-xing, et al. A fast learning algorithm for time-delay neural networks[J].Information Science,2002,148(1-4):27-39","link":"/2019/03/12/%E6%8A%80%E6%9C%AF%E7%AF%87/AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"},{"title":"第一篇 - Welcome to [Hexo]","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment @2018 Made by kakushuu","link":"/2018/05/21/%E6%8A%80%E6%9C%AF%E7%AF%87/guide/hello-world/"},{"title":"Python 导入 Module 错误","text":"ModuleNotFoundError: No module named ‘XXX’ in PythonThe Python “ModuleNotFoundError: No module named ‘XXX’” occurs when we forget to install the XXX module before importing it or install it in an incorrect environment. To solve the error, install the module by running the pip install XXX command.Open your terminal in your project’s root directory and install the XXX module.notice:👇️ in a virtual environment or using Python 2pip install XXX 👇️ for python 3 (could also be pip3.10 depending on your version)pip3 install XXX 👇️ if you get permissions errorsudo pip3 install XXX 👇️ if you don’t have pip in your PATH environment variablepython -m pip install XXX 👇️ for python 3 (could also be pip3.10 depending on your version)python3 -m pip install XXX 👇️ for Anacondaconda install -c anaconda XXX The Python error “ModuleNotFoundError: No module named ‘XXX’” occurs for multiple reasons: Not having the XXX package installed by running pip install XXX. Installing the package in a different Python version than the one you’re using. Installing the package globally and not in your virtual environment. Your IDE running an incorrect version of Python. Naming your module XXX.py which would shadow the official module. Declaring a variable named XXX which would shadow the imported variable. If the error persists, get your Python version and make sure you are installing the package using the correct Python version.For example, my Python version is 3.10.4, so I would install the XXX package with pip3.10 install XXX.pip3.10 install XXX👇️ if you get permissions error use pip3 (NOT pip3.X)sudo pip3 install XXX If the “No module named ‘XXX’” error persists, try restarting your IDE and development server / script. You can check if you have the XXX package installed by running the pip show XXX command. 👇️ check if you have XXX installedpip3 show XXX 👇️ if you don’t have pip setup in PATHpython3 -m pip show XXX The pip show XXX command will either state that the package is not installed or show a bunch of information about the package, including the location where the package is installed. If the package is not installed, make sure your IDE is using the correct version of Python. If you have multiple Python versions installed on your machine, you might have installed the XXX package using the incorrect version or your IDE might be setup to use a different version. For example, In VSCode, you can press CTRL + Shift + P or (⌘ + Shift + P on Mac) to open the command palette. Then type “Python select interpreter” in the field. Your IDE should be using the same version of Python (including the virtual environment) that you are using to install packages from your terminal. 👇️ check if you have XXX installedpip3 show XXX 👇️ if you don’t have pip setup in PATHpython3 -m pip show XXX 👇️ uninstall XXXpip3 uninstall XXX 👇️ if you don’t have pip setup in PATHpython3 -m pip uninstall XXX 👇️ install XXXpip3 install XXX 👇️ if you don’t have pip setup in PATHpython3 -m pip install XXX related blog link:https://bobbyhadz.com/blog/python-no-module-named-numpy","link":"/2022/07/03/%E6%8A%80%E6%9C%AF%E7%AF%87/python/Python-%E5%AF%BC%E5%85%A5-Module-%E9%94%99%E8%AF%AF/"},{"title":"浅谈 Python 中 Synchronously, Multiprocessing, Threading 区别","text":"1.Synchronously: 线性执行 同步方法 耗时长 2.Multiprocessing if it’s CPU bound: The multiprocessing library gives each process its own Python interpreter and each their own GIL(Global Interpreter Lock). allows you to create programs that can run concurrently (bypassing the GIL) use the entirety of your CPU core import multiprocessing def concurrent_multi_process(): dids = [] with concurrent.futures.ProcessPoolExecutor() as executor: results = executor.map(call_out_data, dids) def call_out_data(did): requests.adapters.DEFAULT_RETRIES = 5 url = &quot;http://202.205.91.21:60001/nrmv/canInfo&quot; headers = { 'Content-Type': 'application/json' } payload = json.dumps( { 'appId': &quot;&quot;, &quot;did&quot;: did, &quot;startTime&quot;: 'test', &quot;endTime&quot;: '20220610000000', &quot;limit&quot;: 1000000000, &quot;nextPageStartRowKey&quot;: &quot;&quot;, &quot;reverse&quot;: 'false', &quot;showColumns&quot;: [&quot;`did`&quot;, &quot;`3014`&quot;, &quot;`2602`&quot;, &quot;`2603`&quot;, &quot;`2204`&quot;], &quot;token&quot;: &quot;&quot; }) response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) print(response) if (response.status_code == 200 and 'data' in response.json()): data = response.json()['data'] return data 3.Threading if your program is network bound: it’s perfect for I/O operations such as web scraping because the processor is sitting idle waiting for data. import threading def thread_process(): dids = [] with concurrent.futures.ThreadPoolExecutor() as executor: results = executor.map(call_out_data, dids) 针对中农的大数据服务器，测试了请求3645 次 不同类型下的性能比较，可以看出，使用 thread 方式效果最优秀","link":"/2022/07/05/%E6%8A%80%E6%9C%AF%E7%AF%87/python/%E6%B5%85%E8%B0%88-Python-%E4%B8%AD-Synchronously-Multiprocessing-Threading-%E5%8C%BA%E5%88%AB/"},{"title":"Salesforce 架构篇总结（一）理解 SOC","text":"主要目标 解释 SOC 用于商业的价值在使用一些需求或者平台技术中使用 SOC 来适用一些解决方案将 SOC 应用到 Force.com 中什么时候决定使用 SOC 技术 12345作为一个 salesforce developer 不能仅仅停留在为客户解决一些业务逻辑方面的问题，并且作为一个公司产品的后端程序猿，更为重要的是当产品迭代到一定程度，随着难度的加大以及业务复杂度的加深，我们需要在开发中融入一些重要的编程核心的思想，方便及时发现产品中的 bug 以及对产品后期可扩展性方面都有不错的提升。 对于SOC(Separation of Concerns) 的理解广义上来说SOC是一种分层思想的体现，在大多数OOP语言中都有涉及，这里不再赘述，但需要强调的是，代码的功能模块是可以不断复用的，我们不提倡 copy &amp; paste，但要时刻想着复用，并且类的命名规范（class naming conventions），变量名的命名规范（variable naming conventions）都有助于代码可读性的提升，好的代码如同讲一段优美的故事，That is Good code should tell a story. SOC 的一些好处 顺应技术革命的潮流（Evolution） 技术不断在进步的进步的同时保证代码层级之间是可以扩展，修改，甚至要做到可以使层级之间拆卸自如，回想前端框架数十年发展的太快了，心疼前端小伙伴，各种全家桶层出不穷，学也学不完，都是好学霸 对影响的管控（Impact management）当修改或者拆卸掉一些层级组件的时候，应尽量避免影响到其他层级的功能，除非是出于设计的考究而去有意去修改的 角色及其职能（Roles and responsibility）每一个层级都用其职能，不要低于或者高于其职能，比如丢弃掉一个客户端的应用或者类库，不是意味着丢去掉其业务层的逻辑，因为业务层是另一个层级的职责。 1234567891011121314salesforce 层级分类如下： * 业务逻辑层（Business Logic Layer） 非编码(Declarative): Formula, Validation, Workflow, Process Builder, Sharing Rules 遍码(Coding): Apex Services, Apex Custom Actions * 数据处理层 （Data Access layer） 非编码(Declarative): Data Loaders 编码(Coding): SOQL, SOSL, Salesforce APIs * 数据库层 （Database Layer） 非编码(Declarative): Custom Objects, Fields, Relationships, Rollups 编码(Coding): Apex Triggers 在 Force.com 中使用 SOC 在 App 中替代或者添加另一种 UI（Replacing or adding another UI to your app），需要考虑的是有多少代码需要去重写，或者有些 UI 的端口虽然什么都没做，但是影响到了 App 的 插入（inserting），更新（updating），验证（validating）或者计算处理（calculating）的一些功能。 提供公用 API（Providing a public-facing API）评估一下所实现的 API 使用已有代码库的哪一部分，不要将一些动作行为的方法作为 API 基础的调用 通过 Batch 类来提升应用层逻辑（Scaling your application logic via Batch Apex）使用 Batch 来增大数据吞吐量，使多个用户在登录相同的 UI 页面的时候有相一致的结果 在 Visualforce 页面或者 Lightning Component controllers 中执行复杂的业务逻辑（Working with complex action methods in your Visualforce or Lightning Component controllers）言简意赅，使用 MVC 架构，很老生常谈的东西，在随后的章节会陆续介绍 让一个新的开发人员能快速上手项目的架构（Making it easy for new developers to find their way around your code base）一个新的开发人员花在熟悉代码组织架构的时间也是衡量一个项目好坏的标准之一","link":"/2018/07/09/%E6%8A%80%E6%9C%AF%E7%AF%87/salesforce/salesforce-knowledge-01/"},{"title":"Salesforce 架构篇总结（二）理解 Service 层业务遵循的规则","text":"主要目标 理解 Martin Fowler 为了做企业级架构而分离出 Service 层的缘由理解为什么 Apex 代码要属于 Service 层在应用和平台的开发中如何很好的契合 Service 层的代码在 salesforce 平台上用代码去实现 Service 的架构 简单概述上一篇 Blog 只是简单的介绍了 SOC 思想，将软件的结构抽象到层级应用的逻辑方面，本篇 Blog 主要将目标集中在如何去定义和实现 Service 层，它也是别的层级或者 API 调用的关键步骤。 层级架构之间的关系图： Service 层对实现的业务层、运算层和一些执行业务的逻辑 Process 有一个清晰和严格的封装，同时 service 层必须保证足够的功能专一和抽象，它能够适应后期功能的多次迭代和灵活的可扩展性。下面的内容是如何使用 Apex 代码来实现 Service 层的业务逻辑，同时说明如何在 Force.com 资源有限的情况的下合理的利用资源去实现它。 使用 Service 层的对象客户端（client）执行 Service 层的业务逻辑，比如像 UI controller 或者 Batch Apex 等。 值得考虑使用 Service 层的一些方向： 123456注意：上图中没有提到 Apex Trigger，因为 Trigger 的逻辑属于 Domain layer，它和 Object 联系非常紧密，在 Domain 层的业务逻辑通过 platform UI 或者 APIs 或多或少的会和 Service 层联系到一起 对 Salesforce 平台的创新和适应性的思考想象一下有这么一个场景，当写了一段 feature 代码，需求只要一变就得重新对代码进行重构，或者更糟糕的是由于害怕之前写的逻辑被破坏，索性不敢动之前的逻辑，然后出现了大量的重复的代码，真是很糟糕的体验。 设计上的一些考究 命名规范：Service 层应该足够抽象而且其意义，同时应该很广泛来涵盖客户端的很多情况，这些方面可以表现在对类、方法、参数名的命名规范上，什么时候用动词（verbs），什么时候用名词（nouns）都要有所思考；确保名字所表达的是种一般情况而非特殊情况，举个例子，这个方法名是以业务操作来命名的 InvoiceService.calculateTax(…) ，而第二个方法名是以特定的业务操作来命名的 InvoiceService.handleTaxCodeForACME(…) 应该避像第二种这样的的命名方式 平台 / 协调一致：设计一个签名的算法和 Salesforce 平台进行交互是一个很好的实践，尤其要使用 Bulkificaiton 的时候，一个主要需要考虑的因素是，在所有运行在 Force.com 上的代码都是 Bulkificaiton，要考虑调用服务器端的代码参数数组化，而不是一个单一的参数集，举个例子，这个方法就可以使用 Bulkificaiton =&gt; InvoiceService.calculateTax(List taxCalulations)，而这个方法 =&gt; InvoiceService.calculateTax(Invoice invoice, TaxInfo taxCodeInfo)，由于参数是单一参数集，也应该尽量去避免 SOC 方面的考究：在应用当中 Service 层的代码利用很多 Objects 封装一些任务或者 Process 业务逻辑，与之相对应的是，有些代码关联着特定的 validation、field values 或者 calculations，通过插入、更新、删除触发Trigger 来影响其相对应 Object， 这些代码一般存放在 Trigger 当中，并且可以保留在那里 安全性：Service 层的代码和那些被调用的代码应该确保用户安全，要确保这一点使用 with sharing（with Security Settings enforced）修饰符，尤其需要注意的是如果使用 global 修饰符暴露了太多关键代码，就需要引起注意。如果一个 Apex 类的逻辑必须通过一些 Recodes 让外部的用户可见，那么代码必须提炼它的执行环境，越简略越好，一个好的办法是使用私有的 Apex 内部类，使用 without sharing 关键字 编组：简言之，避免指定如何处理与 Service 层交互的方面错误信息，因为某些方面最好留给服务的调用者，只管原样抛出异常就好（it is typically best to leverage the default error-handling semantics of Apex by throwing exceptions. ） 整合服务：虽然客户端可以一个接一个的执行多次 callout，但这么做会很低效，也会造成一些数据库事务方面的问题，最好的办法是建一个整合服务（ compound services）（compound services），让一次 callout 涵盖多个客户端的请求。同样很重要的是尽可能优化 Service 层的 SOQL 和 DML 操作。当然了这并不意味着不能 callout 更细节的逻辑单元;如果需要的话，可以开发特定的单元去以供客户端 callout 事务管理和无状态： Service 层的客户端经常有一些拥有长存活时间且不同的 Process 请求和一些消息用来执行和处理，举个例子，一个单一的请求和多个请求分隔成单独的作用范围到服务器端：管理状态（比如 Batch Apex）或者复杂的 UI 都是通过它们自己的页面状态来接受很多请求的，在状态管理上最好的方式是在做一次 callout 到 Service 层时，封装数据库操作和服务状态。换句话说，使 Service 端保持无状态，以使调用的环境灵活地使用它们自己的状态管理解决方案。例如，一个在数据库事务的作用域同样应该被包括在每一个 Service 层的方法当中，以便于调用者不用去考虑和其相关的 SavePoints 配置：在 Service 层中，可能有常见的配置或行为被覆盖，合理使用方法重载，接受一个共享的选项参数，类似于 Apex 中的 DML 方法 Service 层在 Apex 中的应用情景介绍：假设在 Opportunity 页面有个自定义 Button 当点击 Button 会出现一个 Visualforce 页面，提示用户对 Opportunity Amount(或相关联的 Opportunity Line)项目应用一个折扣百分比。实例展示如何将 OpportunitiesService.applyDiscounts 方法应用到比如 Visualforce、Batch Apex、 或者 JavaScript Remoting 这些地方上。 下面的 Code 处理的是通过 StandardController 选择的单个 Opportunity，注意：controller 的错误信息是 controller 自己来处理的，而非 service，因为 visualforce 有其自身的错误表现形式。 123456789101112131415public PageReference applyDiscount(){ try { // Apply discount entered to the current Opportunity OpportunitiesService.applyDiscounts(new Set&lt;ID&gt;{ standardController.getId() }, DiscountPercentage); } catch (Exception e) { ApexPages.addMessages(e); } return ApexPages.hasMessages() ? null : standardController.view();} 下面的 Code 展示了通过 StandardSetController 处理多个 Opportunities 12345678910111213141516171819public PageReference applyDiscounts(){ try { // Apply discount entered to the selected Opportunities OpportunitiesService.applyDiscounts( // Tip: Creating a Map from an SObject list gives easy access to the Ids (keys) new Map&lt;Id,SObject&gt;(standardSetController.getSelected()).keyValues(), DiscountPercentage ); } catch (Exception e) { ApexPages.addMessages(e); } return ApexPages.hasMessages() ? null : standardController.view();} 下面的 Code 展示了如何使用 Batch Apex 处理大量的数据，注意和之前代码的区别 123456789101112131415161718192021222324252627282930313233public with sharing class OpportunityApplyDiscountJob implements Database.Batchable&lt;SObject&gt;{ public Decimal DiscountPercentage { get; private set; } public OpportunityApplyDiscountJob(Decimal discountPercentage) { // Discount to apply in this job this.DiscountPercentage = discountPercentage; } public Database.QueryLocator start(Database.BatchableContext ctx) { // Opportunities to discount return Database.getQueryLocator('select Id from Opportunity where StageName = \\'Negotiation/Review\\''); } public void execute(Database.BatchableContext BC, List&lt;sObject&gt; scope) { try { // Call the service OpportunitiesService.applyDiscounts( new Map&lt;Id,SObject&gt;(scope).keySet(),DiscountPercentage); } catch (Exception e) { // Email error, log error, chatter error etc.. } } public void finish(Database.BatchableContext ctx) { }} 下面的 Code 将 service 层打包起来，并且通过 JavaScript Remoting 暴露给客户端，供其调用 12345678910public class OpportunityController{ @RemoteAction public static void applyDiscount(Id opportunityId, Decimal discountPercent) { // Call service OpportunitiesService.applyDiscounts(new Set&lt;ID&gt; { opportunityId }, discountPercent); }} 总结在 Service 层提不断投入对更大的重用性和适应性的都带来很大的好处，同时也为应用程序实现 API 提供了一种更干净、更经济的方式之一。原文：Investing in a service layer for your application offers the engineering benefits of greater reuse and adaptability, as well as provides a cleaner and more cost effective way of implementing an API for your application, a must in today’s cloud-integrated world. By closely observing the encapsulation and design considerations described above, you start to form a durable core for your application that will endure and remain a solid investment throughout the ever-changing and innovative times ahead! 相关资料Separation of concernsMartin Fowler’s Service Layer PatternMartin Fowler’s Enterprise Architecture PatternsLearn Service Layer Principles 知识扩展With Sharing、Without Sharing 和 non-sharing-specified 修饰符的区别 在这里学到 Salesforce 相关的知识的The fun way to learn Salesforce","link":"/2018/11/18/%E6%8A%80%E6%9C%AF%E7%AF%87/salesforce/salesforce-knowledge-02/"},{"title":"Salesforce 架构篇总结（三）Service 层的一些原则","text":"主要目标 创建一个 Service 层的 class 并且在应用中高效的使用暴露出一个用 Service 层做的 API 创建 Service下面介绍的这个方法展示了使用 service 利用 discount 来建立一组 discount 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public with sharing class OpportunitiesService{ public static void applyDiscounts(Set&lt;Id&gt; opportunityIds, Decimal discountPercentage) { // Validate parameters if(opportunityIds == null || opportunityIds.size() == 0) { throw new OpportunityServiceException('Opportunities not specified.'); } if(discountPercentage &lt; 0 || discountPercentage &gt; 100) { throw new OpportunityServiceException('Invalid discount to apply.'); } // Query Opportunities and Lines (SOQL inlined for this example, see Selector pattern in later module) List&lt;Opportunity&gt; opportunities =[select Amount, (select UnitPrice from OpportunityLineItems) from Opportunity where Id in :opportunityIds]; // Update Opportunities and Lines (if present) List&lt;Opportunity&gt; oppsToUpdate = new List&lt;Opportunity&gt;(); List&lt;OpportunityLineItem&gt; oppLinesToUpdate = new List&lt;OpportunityLineItem&gt;(); Decimal factor = 1 - (discountPercentage == null ? 0 : discountPercentage / 100); for(Opportunity opportunity : opportunities) { // Apply to Opportunity Amount if(opportunity.OpportunityLineItems != null &amp;&amp; opportunity.OpportunityLineItems.size() &gt; 0) { for(OpportunityLineItem oppLineItem : opportunity.OpportunityLineItems) { oppLineItem.UnitPrice = oppLineItem.UnitPrice * factor; oppLinesToUpdate.add(oppLineItem); } } else { opportunity.Amount = opportunity.Amount * factor; oppsToUpdate.add(opportunity); } } // Update the database SavePoint sp = Database.setSavePoint(); try { update oppLinesToUpdate; update oppsToUpdate; } catch (Exception e) { // Rollback Database.rollback(sp); // Throw exception on to caller throw e; } } public class OpportunityServiceException extends Exception {}}","link":"/2018/11/20/%E6%8A%80%E6%9C%AF%E7%AF%87/salesforce/salesfroce-knowledge-03/"},{"title":"三亚之行","text":"随便记录一下和公司小伙伴去三亚的美好时光三亚是个好地方，以后有机会一定会再来的，哈哈哈","link":"/2019/05/27/%E7%94%9F%E6%B4%BB%E7%AF%87/%E6%97%85%E8%A1%8C%E6%97%A5%E5%BF%97/%E4%B8%89%E4%BA%9A%E4%B9%8B%E8%A1%8C/"},{"title":"个人介绍","text":"kakushuu | 中国农业大学-在读硕士| felixdeveloper@163.com 语言：英语在学 | 日语在学 | 普通话 | 目前在读：中国农业大学 ｜ 信息科学与工程学院/ 在读研究生 相关技能：Python &amp; Java &amp; HTML &amp; .Net &amp; Apex &amp; JavaScript| Salesforce | Process builder &amp; Lighting LWC | MySQL &amp; PHPSQL | Docker &amp; CLI 工作经历content hidden 校园经历content hidden @2022 Made by kakushuu","link":"/2022/06/30/%E7%94%9F%E6%B4%BB%E7%AF%87/%E8%AE%B0%E5%BD%95/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"},{"title":"node.js 中 nmp 快速下载依赖包","text":"使用 npm i -g nrm 安装 nrm 工具包 使用 nrm ls 列举镜像库,并切换","link":"/2022/08/18/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%89%8D%E7%AB%AF/node-js-%E4%B8%AD-nmp-%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E5%8C%85/"},{"title":"学习 React JS 相关总结","text":"写在前面:最近在写前端，感觉代码在页面不断堆积，以后维护和扩展也是一件头疼的事，对于做过几年后端开发的我来说，不合理的代码组织就像乱糟糟的房间一样看的难受，现在有必要学习这个框架了. 学习链接: 认识 React写了一些 demo，随后集中整理一下","link":"/2022/07/08/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0-React-JS-%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%E4%BD%86%E6%84%BF/"}],"tags":[{"name":"English","slug":"English","link":"/tags/English/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"salesforce","slug":"salesforce","link":"/tags/salesforce/"},{"name":"旅行","slug":"旅行","link":"/tags/%E6%97%85%E8%A1%8C/"},{"name":"个人","slug":"个人","link":"/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"技术篇","slug":"技术篇","link":"/tags/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"技术篇","slug":"技术篇","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"英语","slug":"学习/英语","link":"/categories/%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD/"},{"name":"可视化","slug":"学习/可视化","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"salesforce","slug":"技术篇/salesforce","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/salesforce/"},{"name":"AI","slug":"技术篇/AI","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/AI/"},{"name":"生活篇","slug":"生活篇","link":"/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/"},{"name":"guide","slug":"技术篇/guide","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/guide/"},{"name":"前端","slug":"技术篇/前端","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%89%8D%E7%AB%AF/"},{"name":"python","slug":"技术篇/python","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/python/"},{"name":"旅行日志","slug":"生活篇/旅行日志","link":"/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/%E6%97%85%E8%A1%8C%E6%97%A5%E5%BF%97/"},{"name":"记录","slug":"生活篇/记录","link":"/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/%E8%AE%B0%E5%BD%95/"}]}